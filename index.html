<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WY9KHBJ34L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-WY9KHBJ34L');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letter Rip</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='10' fill='%23f5e6d3'/><rect x='5' y='5' width='90' height='90' rx='8' fill='%23e8d4a0' stroke='%238b7355' stroke-width='3'/><text x='50' y='68' font-size='55' font-weight='bold' text-anchor='middle' fill='%235d3a1a'>L</text><text x='78' y='88' font-size='20' font-weight='bold' text-anchor='middle' fill='%235d3a1a'>1</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2d5016 0%, #4a7c23 50%, #2d5016 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        /* Scale game screen down to fit better */
        .container {
            transform: scale(0.85);
            transform-origin: center center;
        }
        
        .container {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255,255,255,0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            border: 4px solid #8b4513;
        }
        
        h1 {
            text-align: center;
            color: #5d3a1a;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            text-align: center;
            color: #7a4f2a;
            margin-bottom: 20px;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(145deg, #8b4513, #6b3410);
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #f5e6d3;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #d4b896;
            margin-top: 5px;
        }
        
        .board-container {
            margin: 20px auto;
            overflow-x: auto;
            display: flex;
            justify-content: center;
            padding: 10px;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(15, 38px);
            grid-template-rows: repeat(15, 38px);
            gap: 2px;
            background: #2d5016;
            border: 4px solid #1a3009;
            padding: 3px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        .cell {
            background: #c4c4c4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 2px;
        }
        
        .cell:hover {
            background: #d8d8d8;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .cell.dw {
            background: #f5c6c6;
            color: #8b0000;
        }
        
        .cell.tw {
            background: #e63946;
            color: white;
        }
        
        .cell.dl {
            background: #a8d4f0;
            color: #00008b;
        }
        
        .cell.tl {
            background: #1d7ab8;
            color: white;
        }
        
        .cell.center {
            background: #f5c6c6;
            color: #8b4513;
        }
        
        .cell.occupied {
            background: #e8d4a0;
        }
        
        .cell.selected {
            background: #90ee90 !important;
            box-shadow: inset 0 0 0 3px #228b22;
        }
        
        .cell.preview {
            background: #fffacd !important;
        }
        
        .cell.drop-target {
            background: #90ee90 !important;
            box-shadow: inset 0 0 0 3px #228b22;
        }
        
        .cell .premium-label {
            font-size: 13px;
            text-align: center;
            line-height: 1.1;
            font-weight: 800;
            text-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }
        
        .cell .letter {
            font-size: 22px;
            color: #000;
            font-weight: bold;
        }
        
        .cell .points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 9px;
            color: #333;
        }
        
        .rack-container {
            margin: 20px 0;
        }
        
        .rack-label {
            text-align: center;
            font-weight: bold;
            color: #5d3a1a;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .rack {
            display: flex;
            gap: 8px;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(145deg, #8b4513, #6b3410);
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .tile {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border: 2px solid #8b7355;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            position: relative;
            box-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            cursor: grab;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .tile:hover {
            transform: translateY(-5px);
            box-shadow: 3px 8px 10px rgba(0,0,0,0.4);
        }
        
        .tile.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .tile.drag-over {
            transform: scale(1.1);
            border-color: #5d3a1a;
        }
        
        .tile.used {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tile .points {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        
        .rack.rack-drop-target {
            background: rgba(74, 124, 35, 0.2);
            border: 2px dashed #4a7c23;
        }
        
        .cell.dragging-from {
            opacity: 0.5;
        }
        
        .cell.preview .letter {
            cursor: grab;
        }
        
        .cell.preview .letter:active {
            cursor: grabbing;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .submit-container {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            border: 2px solid #8b7355;
        }
        
        .btn-submit-large {
            padding: 15px 50px;
            font-size: 1.2em;
            flex: none;
        }
        
        .btn {
            flex: 1;
            min-width: 100px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        
        .btn-submit {
            background: linear-gradient(145deg, #2d5016, #4a7c23);
            color: white;
        }
        
        .btn-submit:hover {
            background: linear-gradient(145deg, #3d6a1e, #5a8c33);
            transform: translateY(-2px);
        }
        
        .btn-clear {
            background: linear-gradient(145deg, #d4a056, #b8863c);
            color: white;
        }
        
        .btn-clear:hover {
            background: linear-gradient(145deg, #e4b066, #c8964c);
            transform: translateY(-2px);
        }
        
        .btn-new {
            background: linear-gradient(145deg, #8b4513, #6b3410);
            color: white;
        }
        
        .btn-new:hover {
            background: linear-gradient(145deg, #9b5523, #7b4420);
            transform: translateY(-2px);
        }
        
        .feedback {
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        
        .feedback.visible {
            display: block;
        }
        
        .feedback.success {
            background: #d1fae5;
            border: 2px solid #10b981;
        }
        
        .feedback.error {
            background: #fee2e2;
            border: 2px solid #ef4444;
        }
        
        .feedback.info {
            background: #fef3c7;
            border: 2px solid #f59e0b;
        }
        
        .feedback h3 {
            margin-bottom: 10px;
            color: #5d3a1a;
        }
        
        .feedback .score-line {
            font-size: 1.4em;
            font-weight: bold;
            margin: 10px 0;
            color: #5d3a1a;
        }
        
        .better-plays {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #ddd;
        }
        
        .better-plays h4 {
            color: #d4a056;
            margin-bottom: 10px;
        }
        
        .play-option {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #4a7c23;
            font-family: monospace;
        }
        
        /* Mode Selection Screen */
        .mode-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        
        .mode-container {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            border: 4px solid #8b4513;
            transform: scale(0.85);
            margin: auto;
        }
        
        .mode-container h1 {
            color: #5d3a1a;
            margin-bottom: 10px;
        }
        
        .mode-subtitle {
            color: #7a4f2a;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .mode-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .mode-card {
            background: linear-gradient(145deg, #fff, #f5e6d3);
            border: 3px solid #8b4513;
            border-radius: 15px;
            padding: 30px 25px;
            width: 280px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mode-card:hover {
            border-color: #4a7c23;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .mode-card h2 {
            color: #5d3a1a;
            margin-bottom: 10px;
        }
        
        .mode-card p {
            color: #7a4f2a;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        .about-btn {
            margin-top: 30px;
            padding: 10px 25px;
            background: transparent;
            border: 2px solid #8b7355;
            border-radius: 20px;
            color: #5d3a1a;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .about-btn:hover {
            background: rgba(139, 115, 85, 0.2);
            border-color: #5d3a1a;
        }
        
        /* About Modal */
        .about-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .about-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 4px solid #8b4513;
            max-width: 700px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .about-modal h2 {
            color: #5d3a1a;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .about-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border: 2px solid #8b7355;
        }
        
        .about-section h3 {
            color: #5d3a1a;
            margin-bottom: 10px;
            font-size: 1.2em;
            border-bottom: 2px solid #e8d4a0;
            padding-bottom: 8px;
        }
        
        .about-section p {
            color: #5d3a1a;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .about-section ul {
            color: #5d3a1a;
            margin-left: 20px;
            line-height: 1.8;
        }
        
        .about-section li {
            margin-bottom: 5px;
        }
        
        .about-highlight {
            background: #fff8dc;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .efficiency-scale {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .efficiency-item {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .efficiency-excellent { background: #d4edda; color: #155724; }
        .efficiency-good { background: #fff3cd; color: #856404; }
        .efficiency-okay { background: #ffe0cc; color: #c45c00; }
        .efficiency-low { background: #f8d7da; color: #721c24; }
        
        .about-close-btn {
            display: block;
            margin: 20px auto 0;
            padding: 12px 40px;
            background: linear-gradient(145deg, #8b4513, #6b3410);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .about-close-btn:hover {
            background: linear-gradient(145deg, #9b5523, #7b4420);
        }
        
        /* Dictionary warning banner */
        .dictionary-warning {
            background: linear-gradient(145deg, #f8d7da, #f5c6cb);
            border: 2px solid #dc3545;
            border-radius: 10px;
            padding: 15px 20px;
            margin: 15px 0;
            display: none;
        }
        
        .dictionary-warning.visible {
            display: block;
        }
        
        .dictionary-warning-title {
            color: #721c24;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }
        
        .dictionary-warning-text {
            color: #721c24;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        /* Bingo Practice */
        .bingo-letters {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .bingo-letter {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #f5deb3, #deb887);
            border: 3px solid #8b4513;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #5d3a1a;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            cursor: grab;
            user-select: none;
            transition: all 0.15s ease;
        }
        
        .bingo-letter:hover {
            transform: scale(1.05);
            box-shadow: 3px 3px 6px rgba(0,0,0,0.3);
        }
        
        .bingo-letter.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .bingo-letter.drag-over {
            transform: scale(1.1);
            border-color: #4a7c23;
        }
        
        .bingo-letter.used {
            background: linear-gradient(145deg, #a0a0a0, #808080);
            border-color: #606060;
            color: #404040;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3);
        }
        
        .bingo-letter.blank-tile {
            background: linear-gradient(145deg, #f0e6d3, #e0d0b0);
            border-color: #a08060;
            color: #806040;
            font-style: italic;
        }
        
        .shuffle-bingo-btn {
            margin-bottom: 15px;
            padding: 8px 20px;
            font-size: 0.95em;
        }
        
        .bingo-word {
            padding: 8px 15px;
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1.1em;
            font-weight: bold;
            color: #155724;
        }
        
        /* Computer Settings Modal */
        .settings-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
        }
        
        .settings-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 4px solid #8b4513;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            margin: auto;
        }
        
        .settings-modal h2 {
            color: #5d3a1a;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6em;
        }
        
        .settings-section {
            margin-bottom: 25px;
        }
        
        .settings-label {
            display: block;
            color: #5d3a1a;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .settings-description {
            color: #7a4f2a;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        
        .settings-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .settings-options.horizontal {
            flex-direction: row;
        }
        
        .settings-options.horizontal .settings-option {
            flex: 1;
            text-align: center;
            align-items: center;
        }
        
        .settings-option {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 15px;
            background: white;
            border: 3px solid #8b7355;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .settings-option:hover {
            border-color: #5d3a1a;
            background: #fffaf0;
        }
        
        .settings-option.selected {
            border-color: #4a7c23;
            background: #e8f5e0;
        }
        
        .settings-option strong {
            color: #5d3a1a;
            font-size: 1.1em;
            margin-bottom: 3px;
        }
        
        .settings-option span {
            color: #7a4f2a;
            font-size: 0.85em;
        }
        
        .settings-btn-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .settings-btn-row .btn {
            flex: 1;
            max-width: 150px;
        }
        
        /* Live play preview */
        .play-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 12px 20px;
            background: linear-gradient(145deg, #fff, #f5e6d3);
            border: 2px solid #8b4513;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 1.1em;
        }
        
        .preview-label {
            color: #7a4f2a;
        }
        
        .preview-word {
            font-weight: bold;
            color: #5d3a1a;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }
        
        .preview-score {
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .play-preview.empty {
            opacity: 0.5;
        }
        
        /* Computer's rack display */
        .computer-rack-container {
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-radius: 10px;
            border: 2px solid #555;
        }
        
        .computer-last-play {
            text-align: center;
            padding: 10px 15px;
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            color: white;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 1em;
            border: 2px solid #555;
        }
        
        .computer-play-label {
            color: #a0aec0;
        }
        
        #computerPlayText {
            font-weight: bold;
            color: #fff;
        }
        
        .computer-rack-label {
            color: #a0aec0;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .computer-rack {
            display: flex;
            gap: 6px;
            justify-content: center;
        }
        
        .computer-tile {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #4a5568, #2d3748);
            border: 2px solid #718096;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            position: relative;
        }
        
        .computer-tile .points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 9px;
            color: #a0aec0;
        }
        
        .turn-indicator {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .turn-indicator.your-turn {
            background: #d1fae5;
            color: #065f46;
        }
        
        .turn-indicator.computer-turn {
            background: #e0e7ff;
            color: #3730a3;
        }
        
        .drag-hint {
            text-align: center;
            color: #7a4f2a;
            font-size: 0.9em;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .loading-message {
            text-align: center;
            padding: 20px;
        }
        
        .loading-message h2 {
            color: #5d3a1a;
            margin-bottom: 10px;
        }
        
        .loading-message p {
            color: #7a4f2a;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e8d4a0;
            border-top: 4px solid #4a7c23;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Blank tile modal */
        .blank-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .blank-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            border: 4px solid #8b4513;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .blank-modal h3 {
            color: #5d3a1a;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .blank-modal p {
            color: #7a4f2a;
            margin-bottom: 15px;
        }
        
        .letter-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .letter-btn {
            padding: 10px 5px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(145deg, #fff, #f5e6d3);
            border: 2px solid #8b7355;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #5d3a1a;
        }
        
        .letter-btn:hover {
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            border-color: #2d5016;
            transform: scale(1.1);
        }
        
        .cancel-btn {
            padding: 10px 25px;
            font-size: 1em;
            font-weight: bold;
            background: linear-gradient(145deg, #d4a056, #b8863c);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .cancel-btn:hover {
            background: linear-gradient(145deg, #e4b066, #c8964c);
        }
        
        /* Style for blank tiles on board - show they're blanks */
        .cell .letter.blank-letter {
            color: #666;
            font-style: italic;
        }
        
        .tile.is-blank {
            background: linear-gradient(145deg, #fff, #f0f0f0);
            border-style: dashed;
        }
        
        /* Highlight cells for showing better plays */
        .cell.highlight-better {
            background: #ffd700 !important;
            box-shadow: inset 0 0 0 3px #b8860b, 0 0 10px rgba(255, 215, 0, 0.5);
            animation: pulse-highlight 1s ease-in-out infinite;
        }
        
        .cell.highlight-better .letter {
            color: #5d3a1a;
        }
        
        @keyframes pulse-highlight {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .play-option {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #4a7c23;
            font-family: monospace;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .play-option:hover {
            background: #f0f9e8;
            border-left-color: #2d5016;
            transform: translateX(5px);
        }
        
        .play-option.selected {
            background: #fff8dc;
            border-left-color: #ffd700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        /* End game modal */
        .endgame-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .endgame-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 35px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 4px solid #8b4513;
            text-align: center;
            max-width: 450px;
            width: 90%;
        }
        
        .endgame-modal.winner {
            border-color: #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .endgame-modal h2 {
            color: #5d3a1a;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .endgame-modal.winner h2 {
            color: #b8860b;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .endgame-scores {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .endgame-score-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e8d4a0;
            font-size: 1.1em;
        }
        
        .endgame-score-row:last-child {
            border-bottom: none;
        }
        
        .endgame-score-row.total {
            font-weight: bold;
            font-size: 1.3em;
            color: #5d3a1a;
            border-top: 2px solid #8b4513;
            margin-top: 10px;
            padding-top: 15px;
        }
        
        .endgame-score-row .label {
            color: #7a4f2a;
        }
        
        .endgame-score-row .value {
            color: #5d3a1a;
            font-weight: bold;
        }
        
        .endgame-score-row .value.negative {
            color: #c0392b;
        }
        
        .endgame-score-row .value.positive {
            color: #27ae60;
        }
        
        .winner-message {
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
        }
        
        .winner-message.you-win {
            background: linear-gradient(145deg, #ffd700, #ffec8b);
            color: #5d3a1a;
            animation: celebrate 0.5s ease-in-out infinite alternate;
        }
        
        .winner-message.you-lose {
            background: #e0e0e0;
            color: #555;
        }
        
        .winner-message.tie {
            background: linear-gradient(145deg, #c0c0c0, #e0e0e0);
            color: #5d3a1a;
        }
        
        @keyframes celebrate {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            animation: confetti-fall linear forwards;
            z-index: 2001;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        .endgame-btn {
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 10px 5px;
        }
        
        .endgame-btn:hover {
            background: linear-gradient(145deg, #5a8c33, #3d6a1e);
            transform: translateY(-2px);
        }
        
        .endgame-btn.secondary {
            background: linear-gradient(145deg, #8b4513, #6b3410);
        }
        
        .endgame-btn.secondary:hover {
            background: linear-gradient(145deg, #9b5523, #7b4420);
        }
        
        /* Tile swap modal */
        .swap-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .swap-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            border: 4px solid #8b4513;
            text-align: center;
            max-width: 450px;
            width: 90%;
        }
        
        .swap-modal h3 {
            color: #5d3a1a;
            margin-bottom: 10px;
            font-size: 1.3em;
        }
        
        .swap-modal p {
            color: #7a4f2a;
            margin-bottom: 15px;
        }
        
        .swap-tiles-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .swap-tile {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border: 3px solid #8b7355;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            position: relative;
            box-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .swap-tile:hover {
            transform: scale(1.05);
        }
        
        .swap-tile.selected-for-swap {
            background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
            border-color: #c0392b;
            color: white;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .swap-tile .points {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        
        .swap-tile.selected-for-swap .points {
            color: #fff;
        }
        
        .swap-btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .swap-confirm-btn {
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .swap-confirm-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5a8c33, #3d6a1e);
        }
        
        .swap-confirm-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .swap-cancel-btn {
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            background: linear-gradient(145deg, #d4a056, #b8863c);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .swap-cancel-btn:hover {
            background: linear-gradient(145deg, #e4b066, #c8964c);
        }
        
        .swap-count {
            font-size: 1.1em;
            color: #5d3a1a;
            margin: 10px 0;
        }
        
        /* Vocabulary modal */
        .vocab-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .vocab-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            border: 4px solid #8b4513;
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .vocab-modal h2 {
            color: #5d3a1a;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .vocab-word {
            font-size: 2.5em;
            font-weight: bold;
            color: #2d5016;
            letter-spacing: 3px;
            margin: 20px 0;
            text-transform: uppercase;
        }
        
        .vocab-points {
            font-size: 1.1em;
            color: #8b4513;
            margin-bottom: 15px;
        }
        
        .vocab-definition {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
            min-height: 100px;
        }
        
        .vocab-definition .part-of-speech {
            font-style: italic;
            color: #7a4f2a;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .vocab-definition .definition-text {
            color: #333;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .vocab-definition .example {
            color: #666;
            font-style: italic;
            font-size: 0.9em;
            border-left: 3px solid #e8d4a0;
            padding-left: 10px;
            margin-top: 10px;
        }
        
        .vocab-loading {
            color: #7a4f2a;
            font-style: italic;
            padding: 20px;
        }
        
        .vocab-no-definition {
            color: #999;
            font-style: italic;
        }
        
        .vocab-btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .vocab-btn {
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vocab-btn:hover {
            background: linear-gradient(145deg, #5a8c33, #3d6a1e);
            transform: translateY(-2px);
        }
        
        .vocab-btn.secondary {
            background: linear-gradient(145deg, #8b4513, #6b3410);
        }
        
        .vocab-btn.secondary:hover {
            background: linear-gradient(145deg, #9b5523, #7b4420);
        }
        
        .vocab-word-length {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .vocab-length-btn {
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: bold;
            background: linear-gradient(145deg, #e8d4a0, #d4b896);
            color: #5d3a1a;
            border: 2px solid #8b7355;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vocab-length-btn:hover {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
        }
        
        .vocab-length-btn.active {
            background: linear-gradient(145deg, #4a7c23, #2d5016);
            color: white;
            border-color: #2d5016;
        }
        
        /* Hook Words Modal */
        .hook-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .hook-modal {
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 4px solid #8b4513;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .hook-modal h2 {
            color: #5d3a1a;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .hook-word-display {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            border: 2px solid #8b7355;
        }
        
        .hook-base-word {
            font-size: 2.5em;
            font-weight: bold;
            color: #5d3a1a;
            letter-spacing: 3px;
            margin-bottom: 15px;
        }
        
        .hook-input-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .hook-text-input {
            width: 250px;
            padding: 12px 15px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            border: 3px solid #8b7355;
            border-radius: 8px;
            background: linear-gradient(145deg, #f5e6d3, #e8d4a0);
            text-align: center;
        }
        
        .hook-text-input:focus {
            outline: none;
            border-color: #4a7c23;
            box-shadow: 0 0 10px rgba(74, 124, 35, 0.3);
        }
        
        .hook-text-input.correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        
        .hook-text-input.incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        
        .hook-text-input.duplicate {
            border-color: #ffc107;
            background-color: #fff3cd;
        }
        
        .hook-results {
            margin-top: 20px;
            padding: 15px;
            background: #f9f5f0;
            border-radius: 10px;
        }
        
        .hook-results h4 {
            color: #5d3a1a;
            margin-bottom: 10px;
        }
        
        .hook-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .hook-chip {
            padding: 5px 12px;
            background: white;
            border: 2px solid #8b7355;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1em;
        }
        
        .hook-chip.front-hook {
            border-color: #3498db;
            color: #2980b9;
        }
        
        .hook-chip.back-hook {
            border-color: #27ae60;
            color: #1e8449;
        }
        
        .hook-chip.both-hook {
            border-color: #9b59b6;
            color: #7d3c98;
        }
        
        .hook-chip.found {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .hook-score {
            text-align: center;
            margin-top: 15px;
            font-size: 1.1em;
            color: #5d3a1a;
        }
        
        .hook-score span {
            font-weight: bold;
            color: #4a7c23;
        }
        
        .hook-btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .hook-reveal-btn {
            padding: 10px 20px;
            font-size: 0.95em;
            font-weight: bold;
            background: linear-gradient(145deg, #e67e22, #d35400);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .hook-reveal-btn:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
        }
        
        /* Pass/Skip button */
        .btn-skip {
            background: linear-gradient(145deg, #c0392b, #a93226);
            color: white;
        }
        
        .btn-skip:hover {
            background: linear-gradient(145deg, #d04030, #b94236);
        }
        
        /* Pass counter display */
        .pass-counter {
            text-align: center;
            padding: 8px 15px;
            background: rgba(192, 57, 43, 0.1);
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #c0392b;
            display: none;
        }
        
        .pass-counter.visible {
            display: block;
        }
        
        /* Expert mode layout: info LEFT, board MIDDLE, controls RIGHT */
        .container.expert-layout {
            max-width: 1400px;
        }
        
        .expert-game-area {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }
        
        .expert-main-column {
            flex: 0 0 auto;
            order: 2; /* Board in middle */
            margin-top: 0; /* Align with top of side panels */
        }
        
        .expert-side-panel {
            flex: 0 0 280px;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            order: 1; /* Info panel on left */
        }
        
        .expert-right-panel {
            flex: 0 0 200px;
            max-width: 220px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            order: 3; /* Controls on right */
        }
        
        .expert-main-column .board-container {
            margin-top: 0;
        }
        
        /* Hide bottom feedback in expert mode - it shows in side panel */
        .container.expert-layout #feedback {
            display: none !important;
        }
        
        /* Hide bottom pass counter in expert mode */
        .container.expert-layout #passCounter {
            display: none !important;
        }
        
        /* Hide bottom submit container in expert mode */
        .container.expert-layout .submit-container {
            display: none !important;
        }
        
        .side-panel-section {
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #8b7355;
        }
        
        .side-panel-section h3 {
            color: #5d3a1a;
            margin-bottom: 10px;
            font-size: 1em;
            border-bottom: 1px solid #8b7355;
            padding-bottom: 5px;
        }
        
        .side-computer-rack {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
        }
        
        .side-computer-tile {
            width: 38px;
            height: 38px;
            background: linear-gradient(145deg, #d0d0d0, #a0a0a0);
            border: 2px solid #666;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            position: relative;
            color: #333;
        }
        
        .side-computer-tile .points {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 8px;
        }
        
        .side-last-play {
            font-size: 1.1em;
            color: #5d3a1a;
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }
        
        .side-feedback {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .side-feedback .feedback-content {
            font-size: 0.9em;
        }
        
        .side-feedback .feedback-content h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 5px;
        }
        
        .side-feedback .better-plays {
            margin-top: 10px;
        }
        
        .side-feedback .play-option {
            padding: 8px;
            font-size: 0.85em;
        }
        
        /* Side panel buttons */
        .side-controls {
            padding: 12px;
        }
        
        .side-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .side-buttons .btn {
            width: 100%;
            padding: 10px 15px;
            font-size: 0.95em;
        }
        
        .side-pass-counter {
            margin-top: 10px;
            padding: 8px;
            background: rgba(192, 57, 43, 0.1);
            border-radius: 5px;
            font-size: 0.9em;
            color: #c0392b;
            text-align: center;
        }
        
        .side-submit-section {
            padding: 15px;
            display: flex;
            justify-content: center;
        }
        
        .side-submit-btn {
            width: 100%;
            padding: 18px 20px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <!-- Mode Selection Screen -->
    <div class="mode-screen" id="modeScreen">
        <div class="mode-container" id="modeContainer">
            <h1>Letter Rip: Scrabble Practice</h1>
            <p class="mode-subtitle">Choose your game mode</p>
            
            <div class="dictionary-warning" id="dictionaryWarning">
                <div class="dictionary-warning-title"> Limited Dictionary Mode</div>
                <div class="dictionary-warning-text">
                    Could not load the full Scrabble dictionary. Playing with a restricted word list of common words only. 
                    Some valid Scrabble words may not be recognized. Try refreshing the page to attempt loading the full dictionary again.
                </div>
            </div>
            
            <div class="mode-options">
                <div class="mode-card" onclick="startGame('free')">
                    <h2>Free Play</h2>
                    <p>Practice at your own pace. Play words and see how you compare to the best possible plays.</p>
                </div>
                
                <div class="mode-card" onclick="startGame('expert')">
                    <h2>Play Computer</h2>
                    <p>Play against a computer opponent. Choose from beginner, intermediate, or expert difficulty.</p>
                </div>
                
                <div class="mode-card" onclick="openHookWords()">
                    <h2>Hook Words</h2>
                    <p>Practice hook words (letters that can be added to the front or back of existing words).</p>
                </div>
                
                <div class="mode-card" onclick="openBingoPractice()">
                    <h2>Bingo Practice</h2>
                    <p>Practice finding 7 and 8-letter bingos. Use all your tiles for that 50-point bonus.</p>
                </div>
                
                <div class="mode-card" onclick="openVocabulary()">
                    <h2>Vocabulary</h2>
                    <p>Learn new Scrabble words. See random words from the dictionary with their definitions.</p>
                </div>
            </div>
            
            <button class="about-btn" onclick="openAbout()">About This App</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="container" id="gameScreen" style="display: none;">
        <h1>Letter Rip: Scrabble Practice</h1>
        <p class="subtitle">Play the best word and maximize your score!</p>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="totalScore">0</div>
                <div class="stat-label">Total Score</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="efficiency">-</div>
                <div class="stat-label">Efficiency</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="tilesRemaining">93</div>
                <div class="stat-label">Tiles in Bag</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="bestScore">0</div>
                <div class="stat-label">Best Play</div>
            </div>
        </div>
        
        <div id="gameArea">
            <div class="board-container">
                <div class="board" id="board"></div>
            </div>
        </div>
        
        <div class="rack-container">
            <div class="rack-label">Your Tiles:</div>
            <div class="drag-hint">Drag tiles to the board or click a cell and type. Drag tiles in rack to reorder.</div>
            <div class="rack" id="rack"></div>
        </div>
        
        <div class="play-preview" id="playPreview">
            <span class="preview-label">Current play:</span>
            <span class="preview-word" id="previewWord">-</span>
            <span class="preview-score" id="previewScore">0 pts</span>
        </div>
        
        <div class="controls">
            <button class="btn btn-clear" onclick="clearPlay()">Clear Play</button>
            <button class="btn btn-clear" onclick="shuffleRack()">Shuffle</button>
            <button class="btn btn-clear" onclick="openSwapModal()" id="swapBtn">Swap Tiles</button>
            <button class="btn btn-skip" onclick="skipTurn()" id="skipBtn">Pass Turn</button>
        </div>
        
        <div class="submit-container">
            <button class="btn btn-submit btn-submit-large" onclick="submitPlay()">Submit Play</button>
        </div>
        
        <div class="pass-counter" id="passCounter">
            Consecutive passes: <span id="passCount">0</span>/6 (game ends at 6)
        </div>
        
        <div class="controls" style="margin-top: 10px;">
            <button class="btn btn-new" onclick="confirmNewGame()">New Game</button>
            <button class="btn btn-new" onclick="confirmBackToMenu()">Menu</button>
        </div>
        
        <div id="feedback" class="feedback"></div>
        
        <!-- Blank Tile Modal -->
        <div class="blank-modal-overlay" id="blankModal" style="display: none;">
            <div class="blank-modal">
                <h3>Choose a Letter for Your Blank Tile</h3>
                <p>Select what letter this blank tile will represent:</p>
                <div class="letter-grid" id="letterGrid"></div>
                <button class="cancel-btn" onclick="cancelBlankSelection()">Cancel</button>
            </div>
        </div>
        
        <!-- End Game Modal -->
        <div class="endgame-modal-overlay" id="endgameModal" style="display: none;">
            <div class="endgame-modal" id="endgameContent">
                <h2 id="endgameTitle">Game Over!</h2>
                <div class="endgame-scores" id="endgameScores"></div>
                <div class="winner-message" id="winnerMessage"></div>
                <div>
                    <button class="endgame-btn" onclick="playAgain()">Play Again</button>
                    <button class="endgame-btn secondary" onclick="closeEndgameAndMenu()">Main Menu</button>
                </div>
            </div>
        </div>
        
        <!-- Swap Tiles Modal -->
        <div class="swap-modal-overlay" id="swapModal" style="display: none;">
            <div class="swap-modal">
                <h3>Swap Tiles</h3>
                <p>Click tiles to select them for swapping. Selected tiles will be returned to the bag and you'll draw new ones.</p>
                <p style="color: #c0392b; font-weight: bold; font-size: 0.9em;" id="swapTurnWarning"></p>
                <div class="swap-tiles-container" id="swapTilesContainer"></div>
                <div class="swap-count">Selected: <span id="swapCount">0</span> tiles</div>
                <div class="swap-btn-row">
                    <button class="swap-cancel-btn" onclick="cancelSwap()">Cancel</button>
                    <button class="swap-confirm-btn" id="confirmSwapBtn" onclick="confirmSwap()" disabled>Swap Tiles</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Vocabulary Modal (outside gameScreen so it works from main menu) -->
    <div class="vocab-modal-overlay" id="vocabModal" style="display: none;">
        <div class="vocab-modal">
            <h2>Scrabble Vocabulary</h2>
            <p>Filter by word length:</p>
            <div class="vocab-word-length">
                <button class="vocab-length-btn active" onclick="setVocabLength('all')">All</button>
                <button class="vocab-length-btn" onclick="setVocabLength(2)">2</button>
                <button class="vocab-length-btn" onclick="setVocabLength(3)">3</button>
                <button class="vocab-length-btn" onclick="setVocabLength(4)">4</button>
                <button class="vocab-length-btn" onclick="setVocabLength(5)">5</button>
                <button class="vocab-length-btn" onclick="setVocabLength(6)">6</button>
                <button class="vocab-length-btn" onclick="setVocabLength(7)">7</button>
            </div>
            <div class="vocab-word" id="vocabWord">-</div>
            <div class="vocab-points" id="vocabPoints">0 points</div>
            <div class="vocab-definition" id="vocabDefinition">
                <div class="vocab-loading">Click "New Word" to start learning!</div>
            </div>
            <div class="vocab-btn-row">
                <button class="vocab-btn" onclick="showNewWord()">New Word</button>
                <button class="vocab-btn secondary" onclick="closeVocabulary()">Close</button>
            </div>
        </div>
    </div>

    <!-- Hook Words Modal -->
    <div class="hook-modal-overlay" id="hookModal" style="display: none;">
        <div class="hook-modal">
            <h2>Word Extensions Practice</h2>
            <p style="text-align: center; color: #7a4f2a; margin-bottom: 15px;">
                Find words that can be made by adding letters to the front or back of this word.
            </p>
            
            <div class="hook-word-display">
                <div class="hook-base-word" id="hookBaseWord">WORD</div>
                
                <div class="hook-input-area">
                    <input type="text" class="hook-text-input" id="hookGuessInput" placeholder="Type an extension..." onkeypress="handleHookGuess(event)">
                    <button class="vocab-btn" onclick="submitHookGuess()" style="padding: 10px 20px;">Check</button>
                </div>
                
                <div class="hook-hint" style="font-size: 0.85em; color: #7a4f2a; margin-top: 10px;">
                    Examples: If the word is PLANT, try PLANTS, REPLANT, IMPLANT, etc.
                </div>
                
                <div class="hook-score">
                    Found: <span id="hooksFound">0</span> / <span id="hooksTotal">0</span> extensions
                </div>
            </div>
            
            <div class="hook-results" id="hookResults">
                <h4>Your discoveries:</h4>
                <div class="hook-list" id="hookList">
                    <span style="color: #7a4f2a; font-style: italic;">Type a word above to find extensions...</span>
                </div>
            </div>
            
            <div class="hook-btn-row">
                <button class="vocab-btn" onclick="showNewHookWord()">New Word</button>
                <button class="hook-reveal-btn" onclick="revealAllHooks()">Reveal All</button>
                <button class="vocab-btn secondary" onclick="closeHookWords()">Close</button>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div class="about-modal-overlay" id="aboutModal" style="display: none;">
        <div class="about-modal">
            <h2> About Letter Rip</h2>
            
            <div class="about-section" style="background: linear-gradient(145deg, #fff8dc, #f5e6d3); border-color: #d4a574;">
                <p style="text-align: center; font-size: 1.1em; margin: 0;">
                    <em>I made this application to help improve my Scrabble game. <br>While it's tailored to my needs, I hope you find it useful too! -Alex </em>
                </p>
            </div>
            
            <div class="about-section">
                <h3>Free Play Mode</h3>
                <p>Practice Scrabble at your own pace. Place words on the board and get instant feedback on your play quality. You have no opponent in this gameplay.</p>
                <ul>
                    <li><strong>Play Preview:</strong> See your word and score before submitting</li>
                    <li><strong>Better Plays:</strong> After each play, see higher-scoring alternatives you could have made</li>
                    <li><strong>Click to Highlight:</strong> Click any suggested play to see where it would go on the board</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3>Play Computer Mode</h3>
                <p>Play against a computer opponent at your chosen difficulty level. You can tailor difficulty by the computer's ability to pick the highest scoring word and by their defensiveness of high value tiles.</p>
                <ul>
                    <li><strong>Better Plays:</strong> After each play, see higher-scoring alternatives you could have made</li>
                    <li><strong>Skill Level:</strong> Choose beginner, intermediate, or expert for how strong the computer plays</li>
                    <li><strong>Defensiveness:</strong> Choose how much the computer avoids opening premium squares for you</li>
                    <li><strong>Hide Tiles:</strong> Optionally hide the computer's tiles for a more realistic game</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3>Efficiency Score</h3>
                <p>Your efficiency measures how close your plays are to optimal. This is just one way to understand performance, and it is certainly not a complete measure. It's calculated as:</p>
                <p style="text-align: center; font-style: italic; margin: 15px 0;">(Your Points Scored  Best Possible Points)  100%</p>
                <p>For example, if you score 25 points but the best play was worth 30, that turn's efficiency is 83%.</p>
                <div class="efficiency-scale">
                    <span class="efficiency-item efficiency-excellent">90%+ Excellent</span>
                    <span class="efficiency-item efficiency-good">75-89% Good</span>
                    <span class="efficiency-item efficiency-okay">60-74% Okay</span>
                    <span class="efficiency-item efficiency-low">&lt;60% Needs Work</span>
                </div>
                <p style="margin-top: 15px;">You'll also get a warning if your play opens up a Triple Word square for your opponent.</p>
            </div>
            
            <div class="about-section">
                <h3>Vocabulary Mode</h3>
                <p>Expand your Scrabble vocabulary by learning new words.</p>
                <ul>
                    <li><strong>Random Words:</strong> See words from the official Scrabble dictionary</li>
                    <li><strong>Filter by Length:</strong> Focus on 2-letter words, 7-letter bingos, or any length</li>
                    <li><strong>Definitions:</strong> Learn what each word means (when available)</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3>Word Extensions (Hook Words)</h3>
                <p>Master the art of extending existing wordsa crucial Scrabble skill.</p>
                <ul>
                    <li><strong>Front Extensions:</strong> Add letters to the beginning (PLANT  REPLANT)</li>
                    <li><strong>Back Extensions:</strong> Add letters to the end (PLANT  PLANTS)</li>
                    <li><strong>Both Sides:</strong> Some words can extend both ways (PLANT  REPLANTS)</li>
                    <li><strong>Practice:</strong> Type extensions and get instant feedback</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3>Bingo Practice</h3>
                <p>Practice finding 7 and 8-letter words that use all your tiles for the 50-point bingo bonus.</p>
                <ul>
                    <li><strong>Letter Combos:</strong> Given a set of letters, find all valid bingos</li>
                    <li><strong>Track Progress:</strong> See how many bingos you've found vs. total possible</li>
                    <li><strong>Essential Skill:</strong> Finding bingos consistently separates good players from great ones</li>
                </ul>
            </div>
            
            <button class="about-close-btn" onclick="closeAbout()">Got It!</button>
        </div>
    </div>

    <!-- Bingo Practice Modal -->
    <div class="hook-modal-overlay" id="bingoModal" style="display: none;">
        <div class="hook-modal">
            <h2>Bingo Practice</h2>
            <p style="text-align: center; color: #7a4f2a; margin-bottom: 15px;">
                Find all words that use ALL of these letters. Bingos earn a 50-point bonus in Scrabble.
            </p>
            
            <div class="hook-word-display">
                <div class="bingo-letters" id="bingoLetters">
                    <span class="bingo-letter">A</span>
                    <span class="bingo-letter">B</span>
                    <span class="bingo-letter">C</span>
                    <span class="bingo-letter">D</span>
                    <span class="bingo-letter">E</span>
                    <span class="bingo-letter">F</span>
                    <span class="bingo-letter">G</span>
                </div>
                
                <button class="vocab-btn shuffle-bingo-btn" onclick="shuffleBingoLetters()">Shuffle</button>
                
                <div class="hook-input-area">
                    <input type="text" class="hook-text-input" id="bingoGuessInput" placeholder="Type a bingo word..." onkeypress="handleBingoGuess(event)" oninput="updateBingoLetterHighlights()">
                    <button class="vocab-btn" onclick="submitBingoGuess()" style="padding: 10px 20px;">Check</button>
                </div>
                
                <div class="bingo-hint" style="font-size: 0.85em; color: #7a4f2a; margin-top: 10px;">
                    Use ALL letters exactly once. Drag letters to rearrange them.
                </div>
                
                <div class="hook-score">
                    Found: <span id="bingosFound">0</span> / <span id="bingosTotal">0</span> bingos
                </div>
            </div>
            
            <div class="hook-results" id="bingoResults">
                <h4>Your discoveries:</h4>
                <div class="hook-list" id="bingoList">
                    <span style="color: #7a4f2a; font-style: italic;">Type a word above to find bingos...</span>
                </div>
            </div>
            
            <div class="hook-btn-row">
                <button class="vocab-btn" onclick="showNewBingo()">New Letters</button>
                <button class="hook-reveal-btn" onclick="revealAllBingos()">Reveal All</button>
                <button class="vocab-btn secondary" onclick="closeBingoPractice()">Close</button>
            </div>
        </div>
    </div>

    <!-- Computer Settings Modal -->
    <div class="settings-modal-overlay" id="computerSettingsModal" style="display: none;">
        <div class="settings-modal">
            <h2>Computer Opponent Settings</h2>
            
            <div class="settings-section">
                <label class="settings-label">Skill Level</label>
                <p class="settings-description">How strong should the computer play?</p>
                <div class="settings-options">
                    <button class="settings-option" data-skill="beginner" onclick="selectSkillLevel('beginner')">
                        <strong>Beginner</strong>
                        <span>Plays weaker moves (bottom 30% of options)</span>
                    </button>
                    <button class="settings-option" data-skill="intermediate" onclick="selectSkillLevel('intermediate')">
                        <strong>Intermediate</strong>
                        <span>Plays good moves with some variance (top 65% of options)</span>
                    </button>
                    <button class="settings-option selected" data-skill="expert" onclick="selectSkillLevel('expert')">
                        <strong>Expert</strong>
                        <span>Always plays the highest-scoring move</span>
                    </button>
                </div>
            </div>
            
            <div class="settings-section">
                <label class="settings-label">Defensiveness</label>
                <p class="settings-description">How much should the computer avoid setting you up for big plays?</p>
                <div class="settings-options">
                    <button class="settings-option" data-defense="low" onclick="selectDefensiveness('low')">
                        <strong>Low</strong>
                        <span>Focuses on scoring, ignores board openings</span>
                    </button>
                    <button class="settings-option selected" data-defense="medium" onclick="selectDefensiveness('medium')">
                        <strong>Medium</strong>
                        <span>Balances scoring with avoiding dangerous setups</span>
                    </button>
                    <button class="settings-option" data-defense="high" onclick="selectDefensiveness('high')">
                        <strong>High</strong>
                        <span>Strongly avoids opening premium squares</span>
                    </button>
                </div>
            </div>
            
            <div class="settings-section">
                <label class="settings-label">Computer Tiles Visibility</label>
                <p class="settings-description">Can you see what tiles the computer has?</p>
                <div class="settings-options horizontal">
                    <button class="settings-option selected" data-visibility="show" onclick="selectTileVisibility('show')">
                        <strong>Show Tiles</strong>
                    </button>
                    <button class="settings-option" data-visibility="hide" onclick="selectTileVisibility('hide')">
                        <strong>Hide Tiles</strong>
                    </button>
                </div>
            </div>
            
            <div class="settings-btn-row">
                <button class="btn btn-submit" onclick="startGameWithSettings()">Start Game</button>
                <button class="btn btn-clear" onclick="closeComputerSettings()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Scrabble dictionary - will be loaded from GitHub
        let DICTIONARY = new Set();
        let dictionaryLoaded = false;
        let usingFallbackDictionary = false;
        
        // Load the official Scrabble dictionary
        async function loadDictionary() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/redbo/scrabble/master/dictionary.txt');
                if (!response.ok) throw new Error('Failed to fetch');
                const text = await response.text();
                const words = text.split('\n').map(w => w.trim().toUpperCase()).filter(w => w.length > 0);
                DICTIONARY = new Set(words);
                dictionaryLoaded = true;
                usingFallbackDictionary = false;
                console.log(`Dictionary loaded: ${DICTIONARY.size} words`);
                hideDictionaryWarning();
                return true;
            } catch (error) {
                console.error('Failed to load dictionary from GitHub, using fallback:', error);
                usingFallbackDictionary = true;
                showDictionaryWarning();
                // Fallback to basic dictionary
                DICTIONARY = new Set([
                    // 2-letter words (official)
                    'AA', 'AB', 'AD', 'AE', 'AG', 'AH', 'AI', 'AL', 'AM', 'AN', 'AR', 'AS', 'AT', 'AW', 'AX', 'AY',
                    'BA', 'BE', 'BI', 'BO', 'BY', 'DA', 'DE', 'DO', 'ED', 'EF', 'EH', 'EL', 'EM', 'EN', 'ER', 'ES', 'ET', 'EX',
                    'FA', 'FE', 'GI', 'GO', 'HA', 'HE', 'HI', 'HM', 'HO', 'ID', 'IF', 'IN', 'IS', 'IT', 'JO', 'KA', 'KI', 'LA', 'LI', 'LO',
                    'MA', 'ME', 'MI', 'MM', 'MO', 'MU', 'MY', 'NA', 'NE', 'NO', 'NU', 'OD', 'OE', 'OF', 'OH', 'OI', 'OK', 'OM', 'ON', 'OP', 'OR', 'OS', 'OW', 'OX', 'OY',
                    'PA', 'PE', 'PI', 'PO', 'QI', 'RE', 'SH', 'SI', 'SO', 'TA', 'TI', 'TO', 'UH', 'UM', 'UN', 'UP', 'US', 'UT', 'WE', 'WO', 'XI', 'XU', 'YA', 'YE', 'YO', 'ZA',
                    // Common 3-letter words
                    'ACE', 'ACT', 'ADD', 'ADO', 'ADS', 'AFT', 'AGE', 'AGO', 'AID', 'AIM', 'AIR', 'ALE', 'ALL', 'AND', 'ANT', 'ANY', 'APE', 'ARC', 'ARE', 'ARK', 'ARM', 'ART', 'ASH', 'ASK', 'ATE', 'AWE', 'AXE',
                    'BAD', 'BAG', 'BAN', 'BAR', 'BAT', 'BAY', 'BED', 'BEE', 'BET', 'BIG', 'BIN', 'BIT', 'BOB', 'BOG', 'BOW', 'BOX', 'BOY', 'BRA', 'BUD', 'BUG', 'BUM', 'BUN', 'BUS', 'BUT', 'BUY',
                    'CAB', 'CAM', 'CAN', 'CAP', 'CAR', 'CAT', 'COB', 'COD', 'COG', 'COP', 'COT', 'COW', 'COX', 'COY', 'CRY', 'CUB', 'CUD', 'CUE', 'CUP', 'CUR', 'CUT',
                    'DAB', 'DAD', 'DAM', 'DAY', 'DEN', 'DEW', 'DID', 'DIE', 'DIG', 'DIM', 'DIN', 'DIP', 'DOC', 'DOE', 'DOG', 'DON', 'DOT', 'DRY', 'DUB', 'DUD', 'DUE', 'DUG', 'DUN', 'DUO', 'DYE',
                    'EAR', 'EAT', 'EEL', 'EGG', 'EGO', 'ELF', 'ELK', 'ELM', 'EMU', 'END', 'ERA', 'ERR', 'EVE', 'EWE', 'EYE',
                    'FAD', 'FAN', 'FAR', 'FAT', 'FAX', 'FED', 'FEE', 'FEN', 'FEW', 'FIG', 'FIN', 'FIR', 'FIT', 'FIX', 'FLU', 'FLY', 'FOB', 'FOE', 'FOG', 'FOP', 'FOR', 'FOX', 'FRY', 'FUN', 'FUR',
                    'GAB', 'GAG', 'GAL', 'GAP', 'GAS', 'GAY', 'GEL', 'GEM', 'GET', 'GIG', 'GIN', 'GNU', 'GOB', 'GOD', 'GOT', 'GUM', 'GUN', 'GUT', 'GUY', 'GYM',
                    'HAD', 'HAG', 'HAM', 'HAS', 'HAT', 'HAY', 'HEM', 'HEN', 'HER', 'HEW', 'HEX', 'HEY', 'HID', 'HIM', 'HIP', 'HIS', 'HIT', 'HOB', 'HOD', 'HOE', 'HOG', 'HOP', 'HOT', 'HOW', 'HUB', 'HUE', 'HUG', 'HUM', 'HUT',
                    'ICE', 'ICY', 'ILL', 'IMP', 'INK', 'INN', 'ION', 'IRE', 'IRK', 'ITS', 'IVY',
                    'JAB', 'JAG', 'JAM', 'JAR', 'JAW', 'JAY', 'JET', 'JIG', 'JOB', 'JOG', 'JOT', 'JOY', 'JUG', 'JUT',
                    'KEG', 'KEN', 'KEY', 'KID', 'KIN', 'KIT',
                    'LAB', 'LAC', 'LAD', 'LAG', 'LAP', 'LAW', 'LAX', 'LAY', 'LEA', 'LED', 'LEG', 'LET', 'LID', 'LIE', 'LIP', 'LIT', 'LOG', 'LOT', 'LOW', 'LUG',
                    'MAD', 'MAN', 'MAP', 'MAR', 'MAT', 'MAW', 'MAX', 'MAY', 'MEN', 'MET', 'MID', 'MIX', 'MOB', 'MOM', 'MOP', 'MOW', 'MUD', 'MUG', 'MUM',
                    'NAB', 'NAG', 'NAP', 'NAY', 'NET', 'NEW', 'NIB', 'NIL', 'NIT', 'NOB', 'NOD', 'NOR', 'NOT', 'NOW', 'NUB', 'NUN', 'NUT',
                    'OAK', 'OAR', 'OAT', 'ODD', 'ODE', 'OFF', 'OFT', 'OHM', 'OIL', 'OLD', 'ONE', 'OPT', 'ORB', 'ORE', 'OUR', 'OUT', 'OWE', 'OWL', 'OWN',
                    'PAD', 'PAL', 'PAN', 'PAP', 'PAR', 'PAT', 'PAW', 'PAX', 'PAY', 'PEA', 'PEG', 'PEN', 'PEP', 'PER', 'PET', 'PEW', 'PIE', 'PIG', 'PIN', 'PIT', 'PLY', 'POD', 'POP', 'POT', 'POW', 'POX', 'PRO', 'PRY', 'PUB', 'PUG', 'PUN', 'PUP', 'PUS', 'PUT',
                    'RAD', 'RAG', 'RAM', 'RAN', 'RAP', 'RAT', 'RAW', 'RAY', 'RED', 'REF', 'REP', 'RIB', 'RID', 'RIG', 'RIM', 'RIP', 'ROB', 'ROD', 'ROE', 'ROT', 'ROW', 'RUB', 'RUG', 'RUM', 'RUN', 'RUT', 'RYE',
                    'SAC', 'SAD', 'SAG', 'SAP', 'SAT', 'SAW', 'SAX', 'SAY', 'SEA', 'SET', 'SEW', 'SEX', 'SHE', 'SHY', 'SIN', 'SIP', 'SIR', 'SIS', 'SIT', 'SIX', 'SKI', 'SKY', 'SLY', 'SOB', 'SOD', 'SON', 'SOP', 'SOT', 'SOW', 'SOX', 'SOY', 'SPA', 'SPY', 'STY', 'SUB', 'SUM', 'SUN', 'SUP',
                    'TAB', 'TAD', 'TAG', 'TAN', 'TAP', 'TAR', 'TAT', 'TAX', 'TEA', 'TEN', 'THE', 'THY', 'TIC', 'TIE', 'TIN', 'TIP', 'TOE', 'TON', 'TOO', 'TOP', 'TOT', 'TOW', 'TOY', 'TRY', 'TUB', 'TUG', 'TUN', 'TUX', 'TWO',
                    'UGH', 'UMP', 'UNS', 'UPO', 'UPS', 'URN', 'USE', 'UTA', 'UTS',
                    'VAN', 'VAT', 'VET', 'VEX', 'VIA', 'VIE', 'VIM', 'VOW',
                    'WAD', 'WAG', 'WAR', 'WAS', 'WAX', 'WAY', 'WEB', 'WED', 'WEE', 'WET', 'WHO', 'WHY', 'WIG', 'WIN', 'WIT', 'WOE', 'WOK', 'WON', 'WOO', 'WOW',
                    'YAK', 'YAM', 'YAP', 'YAW', 'YEA', 'YEP', 'YES', 'YET', 'YEW', 'YIN', 'YIP', 'YOU', 'YOW', 'YUK', 'YUM', 'YUP',
                    'ZAP', 'ZED', 'ZEE', 'ZEN', 'ZIG', 'ZIP', 'ZIT', 'ZOO'
                ]);
                dictionaryLoaded = true;
                return false;
            }
        }
        
        // Letter point values
        const LETTER_POINTS = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4,
            'I': 1, 'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3,
            'Q': 10, 'R': 1, 'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8,
            'Y': 4, 'Z': 10
        };
        
        // Full Scrabble tile bag (100 tiles total)
        const FULL_BAG = [
            ...Array(9).fill('A'), ...Array(2).fill('B'), ...Array(2).fill('C'),
            ...Array(4).fill('D'), ...Array(12).fill('E'), ...Array(2).fill('F'),
            ...Array(3).fill('G'), ...Array(2).fill('H'), ...Array(9).fill('I'),
            ...Array(1).fill('J'), ...Array(1).fill('K'), ...Array(4).fill('L'),
            ...Array(2).fill('M'), ...Array(6).fill('N'), ...Array(8).fill('O'),
            ...Array(2).fill('P'), ...Array(1).fill('Q'), ...Array(6).fill('R'),
            ...Array(4).fill('S'), ...Array(6).fill('T'), ...Array(4).fill('U'),
            ...Array(2).fill('V'), ...Array(2).fill('W'), ...Array(1).fill('X'),
            ...Array(2).fill('Y'), ...Array(1).fill('Z'), ...Array(2).fill('_') // 2 blanks
        ];
        
        // Premium squares
        const PREMIUM = {
            TW: [[0,0], [0,7], [0,14], [7,0], [7,14], [14,0], [14,7], [14,14]],
            DW: [[1,1], [2,2], [3,3], [4,4], [10,10], [11,11], [12,12], [13,13], 
                 [1,13], [2,12], [3,11], [4,10], [10,4], [11,3], [12,2], [13,1]],
            TL: [[1,5], [1,9], [5,1], [5,5], [5,9], [5,13], [9,1], [9,5], [9,9], [9,13], [13,5], [13,9]],
            DL: [[0,3], [0,11], [2,6], [2,8], [3,0], [3,7], [3,14], [6,2], [6,6], [6,8], [6,12],
                 [7,3], [7,11], [8,2], [8,6], [8,8], [8,12], [11,0], [11,7], [11,14], [12,6], [12,8], [14,3], [14,11]]
        };
        
        // Game state
        let board = [];
        let rack = [];
        let computerRack = [];
        let tileBag = [];
        let selectedCell = null;
        let direction = 'across';
        let currentPlay = [];
        let totalScore = 0;
        let computerScore = 0;
        let bestScore = 0;
        let gameMode = 'free'; // 'free' or 'expert'
        let isPlayerTurn = true;
        let draggedTileIndex = null;
        let draggedTileLetter = null;
        let pendingBlankPlacement = null; // {row, col, rackIndex, isBlank: true}
        let lastBetterPlays = []; // Store better plays with full position data
        let boardStateBeforeComputerPlay = null; // Store board state for expert mode
        let selectedBetterPlayIndex = null; // Track which play is highlighted
        let tilesSelectedForSwap = []; // Track which tile indices are selected for swap
        let vocabLengthFilter = 'all'; // Filter for vocabulary word length
        let consecutivePasses = 0; // Track consecutive passes for game end (6 = game over)
        let computerLastPlayText = ''; // Track computer's last play for side panel display
        let totalPointsScored = 0; // Track total points player scored
        let totalOptimalPoints = 0; // Track total optimal points available
        let turnsPlayed = 0; // Track number of turns for efficiency calc
        let computerSkillLevel = 'expert'; // 'beginner', 'intermediate', 'expert'
        let computerDefensiveness = 'medium'; // 'low', 'medium', 'high'
        let hideComputerTiles = false; // Option to hide computer's tiles from view
        
        // Show blank tile letter selection modal
        function showBlankModal(row, col, rackIndex) {
            pendingBlankPlacement = { row, col, rackIndex };
            
            const modal = document.getElementById('blankModal');
            const grid = document.getElementById('letterGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const btn = document.createElement('button');
                btn.className = 'letter-btn';
                btn.textContent = letter;
                btn.onclick = () => selectBlankLetter(letter);
                grid.appendChild(btn);
            }
            
            modal.style.display = 'flex';
        }
        
        function selectBlankLetter(letter) {
            if (!pendingBlankPlacement) return;
            
            const { row, col } = pendingBlankPlacement;
            
            // Add to current play with isBlank flag
            currentPlay.push({ row, col, letter, isBlank: true });
            
            // Auto-detect direction based on current play
            if (currentPlay.length >= 2) {
                const isAcross = currentPlay.every(p => p.row === currentPlay[0].row);
                const isDown = currentPlay.every(p => p.col === currentPlay[0].col);
                if (isAcross) direction = 'across';
                else if (isDown) direction = 'down';
            }
            
            hideBlankModal();
            renderBoard();
            renderRack();
            updatePlayPreview();
        }
        
        function cancelBlankSelection() {
            pendingBlankPlacement = null;
            hideBlankModal();
        }
        
        function hideBlankModal() {
            document.getElementById('blankModal').style.display = 'none';
            pendingBlankPlacement = null;
        }
        
        function highlightBetterPlay(index) {
            if (index >= lastBetterPlays.length) return;
            
            selectedBetterPlayIndex = index;
            const play = lastBetterPlays[index];
            
            // Update selected state on play options
            document.querySelectorAll('.play-option').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
            
            // Clear existing highlights
            document.querySelectorAll('.cell.highlight-better').forEach(cell => {
                cell.classList.remove('highlight-better');
                // Remove the highlight letter display
                const highlightLetter = cell.querySelector('.highlight-letter');
                if (highlightLetter) highlightLetter.remove();
            });
            
            // Highlight the positions for this play
            const boardDiv = document.getElementById('board');
            play.positions.forEach(pos => {
                const cellIndex = pos.row * 15 + pos.col;
                const cell = boardDiv.children[cellIndex];
                if (cell) {
                    cell.classList.add('highlight-better');
                    
                    // If cell is empty on current board, show what letter would go there
                    if (!board[pos.row][pos.col]) {
                        const letterSpan = document.createElement('span');
                        letterSpan.className = 'letter highlight-letter';
                        letterSpan.textContent = pos.letter;
                        
                        // Clear cell content and add letter
                        const existingContent = cell.innerHTML;
                        cell.dataset.originalContent = existingContent;
                        cell.innerHTML = '';
                        cell.appendChild(letterSpan);
                        
                        const pointsSpan = document.createElement('span');
                        pointsSpan.className = 'points';
                        pointsSpan.textContent = LETTER_POINTS[pos.letter] || 0;
                        cell.appendChild(pointsSpan);
                    }
                }
            });
        }
        
        function clearHighlights() {
            selectedBetterPlayIndex = null;
            
            // Remove selected state from play options
            document.querySelectorAll('.play-option').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Clear highlights and restore original cell content
            document.querySelectorAll('.cell.highlight-better').forEach(cell => {
                cell.classList.remove('highlight-better');
                if (cell.dataset.originalContent) {
                    cell.innerHTML = cell.dataset.originalContent;
                    delete cell.dataset.originalContent;
                }
            });
        }
        
        function calculateRackValue(rackTiles) {
            return rackTiles.reduce((sum, letter) => {
                return sum + (LETTER_POINTS[letter] || 0);
            }, 0);
        }
        
        function checkGameEnd() {
            // Game ends when tile bag is empty AND either player has no tiles
            if (tileBag.length === 0 && (rack.length === 0 || computerRack.length === 0)) {
                endGame();
                return true;
            }
            
            // Standard Scrabble rule: Game ends after 6 consecutive passes (either player)
            if (consecutivePasses >= 6) {
                endGame();
                return true;
            }
            
            return false;
        }
        
        function updatePassCounter() {
            // Update bottom pass counter
            const counter = document.getElementById('passCounter');
            const countSpan = document.getElementById('passCount');
            if (consecutivePasses > 0) {
                counter.classList.add('visible');
                countSpan.textContent = consecutivePasses;
            } else {
                counter.classList.remove('visible');
            }
            
            // Update side panel pass counter (expert mode)
            const sideCounter = document.getElementById('sidePassCounter');
            const sideCountSpan = document.getElementById('sidePassCount');
            if (sideCounter && sideCountSpan) {
                if (consecutivePasses > 0) {
                    sideCounter.style.display = 'block';
                    sideCountSpan.textContent = consecutivePasses;
                } else {
                    sideCounter.style.display = 'none';
                }
            }
        }
        
        function skipTurn() {
            // Clear any current play
            if (currentPlay.length > 0) {
                clearPlay();
            }
            
            consecutivePasses++;
            updatePassCounter();
            
            if (gameMode === 'expert') {
                showFeedback('You passed your turn. Computer is thinking...', 'info');
                
                // Check if game ends due to passes
                if (checkGameEnd()) return;
                
                setTimeout(() => computerTurn(), 1000);
            } else {
                showFeedback('Turn passed. No points scored.', 'info');
                
                // Check if game ends due to passes
                if (checkGameEnd()) return;
            }
        }
        
        function endGame() {
            // Calculate final scores with Scrabble end-game rules
            const playerRackValue = calculateRackValue(rack);
            const computerRackValue = calculateRackValue(computerRack);
            
            let playerFinalScore = totalScore;
            let computerFinalScore = computerScore;
            
            // Deduct remaining tile values from each player
            playerFinalScore -= playerRackValue;
            computerFinalScore -= computerRackValue;
            
            // If a player used all tiles, they get the opponent's remaining tile values
            if (rack.length === 0) {
                playerFinalScore += computerRackValue;
            } else if (computerRack.length === 0) {
                computerFinalScore += playerRackValue;
            }
            
            // Determine winner
            let winner = 'tie';
            if (playerFinalScore > computerFinalScore) {
                winner = 'player';
            } else if (computerFinalScore > playerFinalScore) {
                winner = 'computer';
            }
            
            // Build end reason message
            let endReason = '';
            if (consecutivePasses >= 6) {
                endReason = '<p style="color: #856404; margin-bottom: 15px;"><em>Game ended: 6 consecutive passes</em></p>';
            }
            
            // Build scores display
            const scoresHtml = `
                ${endReason}
                <h3 style="margin-bottom: 15px; color: #5d3a1a;">Final Scoring</h3>
                
                <div style="margin-bottom: 15px;">
                    <strong style="color: #4a7c23;">Your Score</strong>
                    <div class="endgame-score-row">
                        <span class="label">Game Score</span>
                        <span class="value">${totalScore}</span>
                    </div>
                    <div class="endgame-score-row">
                        <span class="label">Tiles Remaining (${rack.join(', ') || 'none'})</span>
                        <span class="value negative">-${playerRackValue}</span>
                    </div>
                    ${rack.length === 0 ? `
                    <div class="endgame-score-row">
                        <span class="label">Bonus (opponent's tiles)</span>
                        <span class="value positive">+${computerRackValue}</span>
                    </div>
                    ` : ''}
                    <div class="endgame-score-row total">
                        <span class="label">Final Score</span>
                        <span class="value">${playerFinalScore}</span>
                    </div>
                </div>
                
                <div>
                    <strong style="color: #c0392b;">Computer Score</strong>
                    <div class="endgame-score-row">
                        <span class="label">Game Score</span>
                        <span class="value">${computerScore}</span>
                    </div>
                    <div class="endgame-score-row">
                        <span class="label">Tiles Remaining (${computerRack.join(', ') || 'none'})</span>
                        <span class="value negative">-${computerRackValue}</span>
                    </div>
                    ${computerRack.length === 0 ? `
                    <div class="endgame-score-row">
                        <span class="label">Bonus (opponent's tiles)</span>
                        <span class="value positive">+${playerRackValue}</span>
                    </div>
                    ` : ''}
                    <div class="endgame-score-row total">
                        <span class="label">Final Score</span>
                        <span class="value">${computerFinalScore}</span>
                    </div>
                </div>
            `;
            
            // Set winner message
            const winnerMessage = document.getElementById('winnerMessage');
            const endgameContent = document.getElementById('endgameContent');
            
            if (winner === 'player') {
                winnerMessage.className = 'winner-message you-win';
                winnerMessage.innerHTML = 'YOU WIN! <br>Congratulations!';
                endgameContent.className = 'endgame-modal winner';
                document.getElementById('endgameTitle').textContent = 'VICTORY!';
                // Trigger confetti
                createConfetti();
            } else if (winner === 'computer') {
                winnerMessage.className = 'winner-message you-lose';
                winnerMessage.textContent = 'Computer Wins';
                endgameContent.className = 'endgame-modal';
                document.getElementById('endgameTitle').textContent = 'Game Over';
            } else {
                winnerMessage.className = 'winner-message tie';
                winnerMessage.textContent = "It's a Tie!";
                endgameContent.className = 'endgame-modal';
                document.getElementById('endgameTitle').textContent = 'Game Over';
            }
            
            document.getElementById('endgameScores').innerHTML = scoresHtml;
            document.getElementById('endgameModal').style.display = 'flex';
        }
        
        function createConfetti() {
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ff9ff3', '#54a0ff'];
            
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.width = (Math.random() * 10 + 5) + 'px';
                    confetti.style.height = (Math.random() * 10 + 5) + 'px';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    document.body.appendChild(confetti);
                    
                    // Remove confetti after animation
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }
        
        function playAgain() {
            document.getElementById('endgameModal').style.display = 'none';
            totalScore = 0;
            computerScore = 0;
            bestScore = 0;
            consecutivePasses = 0;
            lastBetterPlays = [];
            boardStateBeforeComputerPlay = null;
            selectedBetterPlayIndex = null;
            computerLastPlayText = '';
            totalPointsScored = 0;
            totalOptimalPoints = 0;
            turnsPlayed = 0;
            initGame();
            hideFeedback();
            updatePassCounter();
            updateEfficiency();
        }
        
        function closeEndgameAndMenu() {
            document.getElementById('endgameModal').style.display = 'none';
            backToMenu();
        }
        
        function openSwapModal() {
            // Check if there are tiles in the bag
            if (tileBag.length === 0) {
                showFeedback('Cannot swap - no tiles left in the bag!', 'error');
                return;
            }
            
            // Clear any current play first
            if (currentPlay.length > 0) {
                clearPlay();
            }
            
            tilesSelectedForSwap = [];
            
            // Show turn warning in expert mode
            const warningEl = document.getElementById('swapTurnWarning');
            if (gameMode === 'expert') {
                warningEl.textContent = ' Warning: Swapping tiles will forfeit your turn!';
            } else {
                warningEl.textContent = '';
            }
            
            // Build the swap tiles display
            const container = document.getElementById('swapTilesContainer');
            container.innerHTML = '';
            
            rack.forEach((letter, idx) => {
                const tile = document.createElement('div');
                tile.className = 'swap-tile';
                tile.dataset.index = idx;
                tile.innerHTML = `
                    ${letter === '_' ? '' : letter}
                    <span class="points">${LETTER_POINTS[letter] || 0}</span>
                `;
                tile.onclick = () => toggleSwapTile(idx);
                container.appendChild(tile);
            });
            
            updateSwapCount();
            document.getElementById('swapModal').style.display = 'flex';
        }
        
        function toggleSwapTile(index) {
            const idx = tilesSelectedForSwap.indexOf(index);
            if (idx === -1) {
                tilesSelectedForSwap.push(index);
            } else {
                tilesSelectedForSwap.splice(idx, 1);
            }
            
            // Update visual selection
            const tiles = document.querySelectorAll('.swap-tile');
            tiles.forEach((tile, i) => {
                tile.classList.toggle('selected-for-swap', tilesSelectedForSwap.includes(i));
            });
            
            updateSwapCount();
        }
        
        function updateSwapCount() {
            document.getElementById('swapCount').textContent = tilesSelectedForSwap.length;
            const confirmBtn = document.getElementById('confirmSwapBtn');
            confirmBtn.disabled = tilesSelectedForSwap.length === 0;
        }
        
        function cancelSwap() {
            tilesSelectedForSwap = [];
            document.getElementById('swapModal').style.display = 'none';
        }
        
        function confirmSwap() {
            if (tilesSelectedForSwap.length === 0) return;
            
            // Check if there are enough tiles in the bag
            const tilesToSwap = tilesSelectedForSwap.length;
            if (tileBag.length < tilesToSwap) {
                showFeedback(`Not enough tiles in bag! Only ${tileBag.length} tiles available.`, 'error');
                return;
            }
            
            // Get the letters being swapped (sorted by index descending to remove correctly)
            const sortedIndices = [...tilesSelectedForSwap].sort((a, b) => b - a);
            const swappedLetters = sortedIndices.map(i => rack[i]);
            
            // Remove tiles from rack
            sortedIndices.forEach(i => {
                rack.splice(i, 1);
            });
            
            // Draw new tiles
            const newTiles = drawTiles(tilesToSwap);
            rack = [...rack, ...newTiles];
            
            // Put swapped tiles back in bag
            swappedLetters.forEach(letter => {
                tileBag.push(letter);
            });
            shuffleArray(tileBag);
            
            // Close modal and update display
            document.getElementById('swapModal').style.display = 'none';
            tilesSelectedForSwap = [];
            
            renderRack();
            updateStats();
            
            // Swapping counts as a pass for consecutive pass tracking
            consecutivePasses++;
            updatePassCounter();
            
            // In expert mode, this counts as your turn - computer goes next
            if (gameMode === 'expert') {
                showFeedback(`Swapped ${tilesToSwap} tile${tilesToSwap > 1 ? 's' : ''} - turn forfeited. Computer's turn...`, 'info');
                if (checkGameEnd()) return;
                setTimeout(() => computerTurn(), 1500);
            } else {
                showFeedback(`Swapped ${tilesToSwap} tile${tilesToSwap > 1 ? 's' : ''} with the bag. Your turn continues in Free Play mode.`, 'info');
            }
        }
        
        function confirmNewGame() {
            if (confirm('Are you sure you want to start a new game? Your current progress will be lost.')) {
                totalScore = 0;
                computerScore = 0;
                bestScore = 0;
                consecutivePasses = 0;
                lastBetterPlays = [];
                boardStateBeforeComputerPlay = null;
                selectedBetterPlayIndex = null;
                computerLastPlayText = '';
                totalPointsScored = 0;
                totalOptimalPoints = 0;
                turnsPlayed = 0;
                initGame();
                hideFeedback();
                updatePassCounter();
                updateEfficiency();
            }
        }
        
        // Vocabulary functions
        async function openVocabulary() {
            // Make sure dictionary is loaded
            if (!dictionaryLoaded) {
                const modeContainer = document.getElementById('modeContainer');
                const originalContent = modeContainer.innerHTML;
                modeContainer.innerHTML = `
                    <div class="loading-message">
                        <h2>Loading dictionary...</h2>
                        <div class="loading-spinner"></div>
                        <p>Please wait</p>
                    </div>
                `;
                await loadDictionary();
                modeContainer.innerHTML = originalContent;
            }
            
            document.getElementById('vocabModal').style.display = 'flex';
            showNewWord();
        }
        
        function closeVocabulary() {
            document.getElementById('vocabModal').style.display = 'none';
        }
        
        function setVocabLength(length) {
            vocabLengthFilter = length;
            
            // Update active button
            document.querySelectorAll('.vocab-length-btn').forEach(btn => {
                const btnLength = btn.textContent === 'All' ? 'all' : parseInt(btn.textContent);
                btn.classList.toggle('active', btnLength === length);
            });
            
            showNewWord();
        }
        
        function calculateWordPoints(word) {
            return word.split('').reduce((sum, letter) => {
                return sum + (LETTER_POINTS[letter] || 0);
            }, 0);
        }
        
        async function showNewWord() {
            const wordEl = document.getElementById('vocabWord');
            const pointsEl = document.getElementById('vocabPoints');
            const definitionEl = document.getElementById('vocabDefinition');
            
            // Filter words by length
            let filteredWords = Array.from(DICTIONARY);
            if (vocabLengthFilter !== 'all') {
                filteredWords = filteredWords.filter(w => w.length === vocabLengthFilter);
            }
            
            if (filteredWords.length === 0) {
                wordEl.textContent = '-';
                pointsEl.textContent = '0 points';
                definitionEl.innerHTML = '<div class="vocab-no-definition">No words found for this length.</div>';
                return;
            }
            
            // Pick a random word
            const word = filteredWords[Math.floor(Math.random() * filteredWords.length)];
            const points = calculateWordPoints(word);
            
            wordEl.textContent = word;
            pointsEl.textContent = `${points} point${points !== 1 ? 's' : ''} (base value)`;
            definitionEl.innerHTML = '<div class="vocab-loading">Loading definition...</div>';
            
            // Fetch definition from Free Dictionary API
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`);
                
                if (response.ok) {
                    const data = await response.json();
                    let definitionHtml = '';
                    
                    // Get first few meanings
                    const meanings = data[0]?.meanings?.slice(0, 2) || [];
                    
                    if (meanings.length > 0) {
                        meanings.forEach(meaning => {
                            const partOfSpeech = meaning.partOfSpeech;
                            const definitions = meaning.definitions?.slice(0, 2) || [];
                            
                            definitions.forEach(def => {
                                definitionHtml += `<div class="part-of-speech">${partOfSpeech}</div>`;
                                definitionHtml += `<div class="definition-text">${def.definition}</div>`;
                                if (def.example) {
                                    definitionHtml += `<div class="example">"${def.example}"</div>`;
                                }
                            });
                        });
                    }
                    
                    definitionEl.innerHTML = definitionHtml || '<div class="vocab-no-definition">No definition available.</div>';
                } else {
                    definitionEl.innerHTML = '<div class="vocab-no-definition">No definition found. This may be a specialized Scrabble word!</div>';
                }
            } catch (error) {
                definitionEl.innerHTML = '<div class="vocab-no-definition">Could not load definition. Check your internet connection.</div>';
            }
        }
        
        // Hook Words Practice variables
        let currentHookWord = '';
        let allExtensions = []; // All valid extensions of the current word
        let foundExtensions = new Set();
        
        async function openHookWords() {
            // Make sure dictionary is loaded
            if (!dictionaryLoaded) {
                const modeContainer = document.getElementById('modeContainer');
                const originalContent = modeContainer.innerHTML;
                modeContainer.innerHTML = `
                    <div class="loading-message">
                        <h2>Loading dictionary...</h2>
                        <div class="loading-spinner"></div>
                        <p>Please wait</p>
                    </div>
                `;
                await loadDictionary();
                modeContainer.innerHTML = originalContent;
            }
            
            document.getElementById('hookModal').style.display = 'flex';
            showNewHookWord();
        }
        
        function closeHookWords() {
            document.getElementById('hookModal').style.display = 'none';
        }
        
        function openAbout() {
            document.getElementById('aboutModal').style.display = 'flex';
        }
        
        function closeAbout() {
            document.getElementById('aboutModal').style.display = 'none';
        }
        
        function showDictionaryWarning() {
            const warning = document.getElementById('dictionaryWarning');
            if (warning) warning.classList.add('visible');
        }
        
        function hideDictionaryWarning() {
            const warning = document.getElementById('dictionaryWarning');
            if (warning) warning.classList.remove('visible');
        }
        
        // Bingo Practice variables
        let currentBingoLetters = [];
        let allBingos = [];
        let foundBingos = new Set();
        
        function openBingoPractice() {
            // Make sure dictionary is loaded
            if (!dictionaryLoaded) {
                loadDictionary().then(() => {
                    document.getElementById('bingoModal').style.display = 'flex';
                    showNewBingo();
                });
            } else {
                document.getElementById('bingoModal').style.display = 'flex';
                showNewBingo();
            }
        }
        
        function closeBingoPractice() {
            document.getElementById('bingoModal').style.display = 'none';
        }
        
        function sortLetters(word) {
            return word.split('').sort().join('');
        }
        
        function canFormWordWithBlanks(word, availableLetters, blankCount) {
            const letterPool = [...availableLetters];
            let blanksNeeded = 0;
            
            for (const char of word) {
                const idx = letterPool.indexOf(char);
                if (idx !== -1) {
                    letterPool.splice(idx, 1);
                } else {
                    blanksNeeded++;
                }
            }
            
            return blanksNeeded <= blankCount;
        }
        
        function findBingosForLetters(letters) {
            const hasBlank = letters.includes('?');
            const nonBlankLetters = letters.filter(l => l !== '?');
            const blankCount = letters.length - nonBlankLetters.length;
            
            // If no blanks, use the fast sorted comparison
            if (!hasBlank) {
                const sortedInput = sortLetters(letters.join(''));
                const bingos = [];
                
                for (const word of DICTIONARY) {
                    if (word.length === letters.length) {
                        if (sortLetters(word) === sortedInput) {
                            bingos.push(word);
                        }
                    }
                }
                return bingos;
            }
            
            // With blanks, need to check each word individually
            const bingos = [];
            for (const word of DICTIONARY) {
                if (word.length === letters.length) {
                    if (canFormWordWithBlanks(word, nonBlankLetters, blankCount)) {
                        bingos.push(word);
                    }
                }
            }
            
            return bingos;
        }
        
        function generateBingoLetters() {
            // Try to find a set of letters that has at least one bingo
            const vowels = ['A', 'E', 'I', 'O', 'U'];
            const consonants = ['B', 'C', 'D', 'F', 'G', 'H', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'W'];
            
            // Sometimes use 7, sometimes 8 letters
            const numLetters = Math.random() < 0.6 ? 7 : 8;
            
            // ~20% chance to include a blank
            const includeBlank = Math.random() < 0.2;
            
            let attempts = 0;
            while (attempts < 100) {
                const letters = [];
                
                // Add blank first if included
                if (includeBlank) {
                    letters.push('?');
                }
                
                // Generate a balanced rack: 2-3 vowels, rest consonants
                const numVowels = 2 + Math.floor(Math.random() * 2);
                
                for (let i = 0; i < numVowels && letters.length < numLetters; i++) {
                    letters.push(vowels[Math.floor(Math.random() * vowels.length)]);
                }
                while (letters.length < numLetters) {
                    letters.push(consonants[Math.floor(Math.random() * consonants.length)]);
                }
                
                // Shuffle
                for (let i = letters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [letters[i], letters[j]] = [letters[j], letters[i]];
                }
                
                const bingos = findBingosForLetters(letters);
                // Allow more bingos when blank is present since there will be many more
                const maxBingos = includeBlank ? 50 : 20;
                if (bingos.length >= 1 && bingos.length <= maxBingos) {
                    return { letters, bingos };
                }
                attempts++;
            }
            
            // Fallback: pick a random bingo word and shuffle its letters
            const bingoWords = Array.from(DICTIONARY).filter(w => w.length === 7 || w.length === 8);
            if (bingoWords.length > 0) {
                const word = bingoWords[Math.floor(Math.random() * bingoWords.length)];
                const letters = word.split('');
                // Shuffle
                for (let i = letters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [letters[i], letters[j]] = [letters[j], letters[i]];
                }
                return { letters, bingos: findBingosForLetters(letters) };
            }
            
            return { letters: ['S', 'C', 'R', 'A', 'B', 'L', 'E'], bingos: ['SCRABBLE'] };
        }
        
        function showNewBingo() {
            const result = generateBingoLetters();
            currentBingoLetters = result.letters;
            allBingos = result.bingos;
            foundBingos = new Set();
            
            // Update letter display with draggable letters
            renderBingoLetters();
            
            // Reset input and results
            document.getElementById('bingoGuessInput').value = '';
            document.getElementById('bingoGuessInput').className = 'hook-text-input';
            document.getElementById('bingoList').innerHTML = '<span style="color: #7a4f2a; font-style: italic;">Type a word above to find bingos...</span>';
            
            updateBingoScore();
            document.getElementById('bingoGuessInput').focus();
        }
        
        function renderBingoLetters() {
            const lettersDiv = document.getElementById('bingoLetters');
            lettersDiv.innerHTML = currentBingoLetters.map((l, i) => {
                const isBlank = l === '?';
                const blankClass = isBlank ? ' blank-tile' : '';
                const displayLetter = isBlank ? '?' : l;
                return `<span class="bingo-letter${blankClass}" draggable="true" data-index="${i}">${displayLetter}</span>`;
            }).join('');
            
            // Add drag event listeners
            setupBingoDragListeners();
            updateBingoLetterHighlights();
        }
        
        function setupBingoDragListeners() {
            const letters = document.querySelectorAll('.bingo-letter');
            let draggedIndex = null;
            
            letters.forEach(letter => {
                letter.addEventListener('dragstart', (e) => {
                    draggedIndex = parseInt(e.target.dataset.index);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                letter.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    document.querySelectorAll('.bingo-letter').forEach(l => l.classList.remove('drag-over'));
                });
                
                letter.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (!e.target.classList.contains('dragging')) {
                        e.target.classList.add('drag-over');
                    }
                });
                
                letter.addEventListener('dragleave', (e) => {
                    e.target.classList.remove('drag-over');
                });
                
                letter.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const dropIndex = parseInt(e.target.dataset.index);
                    
                    if (draggedIndex !== null && draggedIndex !== dropIndex) {
                        // Swap letters
                        const temp = currentBingoLetters[draggedIndex];
                        currentBingoLetters[draggedIndex] = currentBingoLetters[dropIndex];
                        currentBingoLetters[dropIndex] = temp;
                        
                        renderBingoLetters();
                    }
                    
                    draggedIndex = null;
                });
            });
        }
        
        function shuffleBingoLetters() {
            // Fisher-Yates shuffle
            for (let i = currentBingoLetters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentBingoLetters[i], currentBingoLetters[j]] = [currentBingoLetters[j], currentBingoLetters[i]];
            }
            renderBingoLetters();
            document.getElementById('bingoGuessInput').focus();
        }
        
        function updateBingoLetterHighlights() {
            const input = document.getElementById('bingoGuessInput');
            const typed = input.value.toUpperCase().split('');
            const letterElements = document.querySelectorAll('.bingo-letter');
            
            // Track which letters have been used
            const availableLetters = [...currentBingoLetters];
            const usedIndices = new Set();
            
            typed.forEach(char => {
                // First try to match a regular letter
                let idx = -1;
                for (let i = 0; i < availableLetters.length; i++) {
                    if (availableLetters[i] === char && !usedIndices.has(i)) {
                        idx = i;
                        break;
                    }
                }
                
                // If no regular match, try to use a blank
                if (idx === -1) {
                    for (let i = 0; i < availableLetters.length; i++) {
                        if (availableLetters[i] === '?' && !usedIndices.has(i)) {
                            idx = i;
                            break;
                        }
                    }
                }
                
                if (idx !== -1) {
                    usedIndices.add(idx);
                }
            });
            
            // Update visual state
            letterElements.forEach((el, i) => {
                // Preserve blank-tile class
                const isBlank = currentBingoLetters[i] === '?';
                if (usedIndices.has(i)) {
                    el.classList.add('used');
                } else {
                    el.classList.remove('used');
                }
                if (isBlank) {
                    el.classList.add('blank-tile');
                }
            });
        }
        
        function handleBingoGuess(event) {
            if (event.key === 'Enter') {
                submitBingoGuess();
            }
        }
        
        function submitBingoGuess() {
            const input = document.getElementById('bingoGuessInput');
            const guess = input.value.toUpperCase().trim();
            
            if (guess.length === 0) return;
            
            // Check if it's a valid bingo
            if (allBingos.includes(guess)) {
                if (foundBingos.has(guess)) {
                    // Already found
                    input.className = 'hook-text-input duplicate';
                } else {
                    // Correct!
                    foundBingos.add(guess);
                    input.className = 'hook-text-input correct';
                    updateBingoDisplay();
                    updateBingoScore();
                }
            } else if (guess.length === currentBingoLetters.length) {
                // Check if valid word that can be formed with our letters (including blanks)
                const nonBlankLetters = currentBingoLetters.filter(l => l !== '?');
                const blankCount = currentBingoLetters.length - nonBlankLetters.length;
                
                if (canFormWordWithBlanks(guess, nonBlankLetters, blankCount) && DICTIONARY.has(guess)) {
                    // Valid word using all letters but we didn't find it - add it!
                    allBingos.push(guess);
                    foundBingos.add(guess);
                    input.className = 'hook-text-input correct';
                    updateBingoDisplay();
                    updateBingoScore();
                } else {
                    // Incorrect
                    input.className = 'hook-text-input incorrect';
                }
            } else {
                // Incorrect
                input.className = 'hook-text-input incorrect';
            }
            
            // Reset after delay
            setTimeout(() => {
                input.value = '';
                input.className = 'hook-text-input';
                updateBingoLetterHighlights(); // Clear highlights
                input.focus();
            }, 600);
        }
        
        function updateBingoDisplay() {
            const bingoList = document.getElementById('bingoList');
            
            if (foundBingos.size === 0) {
                bingoList.innerHTML = '<span style="color: #7a4f2a; font-style: italic;">Type a word above to find bingos...</span>';
                return;
            }
            
            let html = '';
            foundBingos.forEach(word => {
                html += `<span class="bingo-word">${word}</span> `;
            });
            
            bingoList.innerHTML = html;
        }
        
        function updateBingoScore() {
            document.getElementById('bingosFound').textContent = foundBingos.size;
            document.getElementById('bingosTotal').textContent = allBingos.length;
        }
        
        function revealAllBingos() {
            const bingoList = document.getElementById('bingoList');
            
            if (allBingos.length === 0) {
                bingoList.innerHTML = '<span style="color: #7a4f2a; font-style: italic;">No bingos possible with these letters.</span>';
                return;
            }
            
            let html = '';
            allBingos.forEach(word => {
                const found = foundBingos.has(word);
                html += `<span class="bingo-word" style="${found ? '' : 'background: #fff3cd; border-color: #ffc107; color: #856404;'}">${word}</span> `;
            });
            
            bingoList.innerHTML = html;
            
            // Mark all as found for the score
            allBingos.forEach(word => foundBingos.add(word));
            updateBingoScore();
        }
        
        function findAllExtensions(word) {
            const extensions = [];
            
            // Find all words that contain our word as a substring
            for (const dictWord of DICTIONARY) {
                if (dictWord === word) continue; // Skip the word itself
                if (dictWord.length <= word.length) continue; // Must be longer
                if (dictWord.length > word.length + 5) continue; // Limit extension length for practicality
                
                // Check if dictWord contains our word
                const index = dictWord.indexOf(word);
                if (index !== -1) {
                    const prefix = dictWord.substring(0, index);
                    const suffix = dictWord.substring(index + word.length);
                    
                    // Categorize the extension
                    let type = '';
                    if (prefix && suffix) {
                        type = 'both'; // Letters added to both sides
                    } else if (prefix) {
                        type = 'front'; // Letters added to front
                    } else if (suffix) {
                        type = 'back'; // Letters added to back
                    }
                    
                    extensions.push({
                        word: dictWord,
                        type: type,
                        prefix: prefix,
                        suffix: suffix
                    });
                }
            }
            
            return extensions;
        }
        
        function showNewHookWord() {
            // Pre-select some good base words (common 3-5 letter words)
            // This is faster than scanning the entire dictionary
            const goodBaseWords = Array.from(DICTIONARY).filter(w => w.length >= 3 && w.length <= 5);
            
            // Try a few random words until we find one with good extensions
            let attempts = 0;
            let currentHookWordTemp = '';
            let extensionsTemp = [];
            
            while (attempts < 50) {
                currentHookWordTemp = goodBaseWords[Math.floor(Math.random() * goodBaseWords.length)];
                extensionsTemp = findAllExtensions(currentHookWordTemp);
                
                if (extensionsTemp.length >= 3 && extensionsTemp.length <= 50) {
                    break;
                }
                attempts++;
            }
            
            if (extensionsTemp.length < 1) {
                alert('Could not find a suitable word. Try again!');
                return;
            }
            
            currentHookWord = currentHookWordTemp;
            allExtensions = extensionsTemp;
            foundExtensions = new Set();
            
            // Update display
            document.getElementById('hookBaseWord').textContent = currentHookWord;
            document.getElementById('hookGuessInput').value = '';
            document.getElementById('hookGuessInput').className = 'hook-text-input';
            document.getElementById('hookList').innerHTML = '<span style="color: #7a4f2a; font-style: italic;">Type a word above to find extensions...</span>';
            
            updateHookScore();
            
            // Focus the input
            document.getElementById('hookGuessInput').focus();
        }
        
        function handleHookGuess(event) {
            if (event.key === 'Enter') {
                submitHookGuess();
            }
        }
        
        function submitHookGuess() {
            const input = document.getElementById('hookGuessInput');
            const guess = input.value.toUpperCase().trim();
            
            if (guess.length === 0) return;
            
            // Check if it's a valid extension
            const extension = allExtensions.find(e => e.word === guess);
            
            if (extension) {
                if (foundExtensions.has(guess)) {
                    // Already found
                    input.className = 'hook-text-input duplicate';
                } else {
                    // Correct!
                    foundExtensions.add(guess);
                    input.className = 'hook-text-input correct';
                    updateHookDisplay();
                    updateHookScore();
                }
            } else if (DICTIONARY.has(guess) && guess.includes(currentHookWord)) {
                // Valid word containing our word, but maybe too long for our list
                input.className = 'hook-text-input correct';
                if (!foundExtensions.has(guess)) {
                    foundExtensions.add(guess);
                    // Add it to extensions if not there
                    if (!allExtensions.find(e => e.word === guess)) {
                        const index = guess.indexOf(currentHookWord);
                        allExtensions.push({
                            word: guess,
                            type: index > 0 && index + currentHookWord.length < guess.length ? 'both' : (index > 0 ? 'front' : 'back'),
                            prefix: guess.substring(0, index),
                            suffix: guess.substring(index + currentHookWord.length)
                        });
                    }
                    updateHookDisplay();
                    updateHookScore();
                }
            } else {
                // Incorrect
                input.className = 'hook-text-input incorrect';
            }
            
            // Reset after delay
            setTimeout(() => {
                input.value = '';
                input.className = 'hook-text-input';
                input.focus();
            }, 600);
        }
        
        function updateHookDisplay() {
            const hookList = document.getElementById('hookList');
            
            if (foundExtensions.size === 0) {
                hookList.innerHTML = '<span style="color: #7a4f2a; font-style: italic;">Type a word above to find extensions...</span>';
                return;
            }
            
            // Sort found extensions by type
            const frontExts = [];
            const backExts = [];
            const bothExts = [];
            
            foundExtensions.forEach(word => {
                const ext = allExtensions.find(e => e.word === word);
                if (ext) {
                    if (ext.type === 'front') frontExts.push(ext);
                    else if (ext.type === 'back') backExts.push(ext);
                    else bothExts.push(ext);
                }
            });
            
            let html = '';
            
            if (frontExts.length > 0) {
                frontExts.forEach(ext => {
                    html += `<span class="hook-chip front-hook found"><strong>${ext.prefix}</strong>${currentHookWord}</span>`;
                });
            }
            
            if (backExts.length > 0) {
                backExts.forEach(ext => {
                    html += `<span class="hook-chip back-hook found">${currentHookWord}<strong>${ext.suffix}</strong></span>`;
                });
            }
            
            if (bothExts.length > 0) {
                bothExts.forEach(ext => {
                    html += `<span class="hook-chip both-hook found"><strong>${ext.prefix}</strong>${currentHookWord}<strong>${ext.suffix}</strong></span>`;
                });
            }
            
            hookList.innerHTML = html;
        }
        
        function updateHookScore() {
            document.getElementById('hooksFound').textContent = foundExtensions.size;
            document.getElementById('hooksTotal').textContent = allExtensions.length;
        }
        
        function revealAllHooks() {
            const hookList = document.getElementById('hookList');
            
            // Sort extensions by type
            const frontExts = allExtensions.filter(e => e.type === 'front');
            const backExts = allExtensions.filter(e => e.type === 'back');
            const bothExts = allExtensions.filter(e => e.type === 'both');
            
            let html = '';
            
            if (frontExts.length > 0) {
                html += '<div style="width: 100%; margin-bottom: 10px;"><strong style="color: #3498db;">Front extensions (' + frontExts.length + '):</strong></div>';
                frontExts.forEach(ext => {
                    const found = foundExtensions.has(ext.word);
                    html += `<span class="hook-chip front-hook ${found ? 'found' : ''}"><strong>${ext.prefix}</strong>${currentHookWord}</span>`;
                });
            }
            
            if (backExts.length > 0) {
                html += '<div style="width: 100%; margin: 10px 0;"><strong style="color: #27ae60;">Back extensions (' + backExts.length + '):</strong></div>';
                backExts.forEach(ext => {
                    const found = foundExtensions.has(ext.word);
                    html += `<span class="hook-chip back-hook ${found ? 'found' : ''}">${currentHookWord}<strong>${ext.suffix}</strong></span>`;
                });
            }
            
            if (bothExts.length > 0) {
                html += '<div style="width: 100%; margin: 10px 0;"><strong style="color: #9b59b6;">Both sides (' + bothExts.length + '):</strong></div>';
                bothExts.forEach(ext => {
                    const found = foundExtensions.has(ext.word);
                    html += `<span class="hook-chip both-hook ${found ? 'found' : ''}"><strong>${ext.prefix}</strong>${currentHookWord}<strong>${ext.suffix}</strong></span>`;
                });
            }
            
            if (allExtensions.length === 0) {
                html = '<span style="color: #7a4f2a; font-style: italic;">This word has no extensions in the dictionary.</span>';
            }
            
            hookList.innerHTML = html;
            
            // Mark all as found for the score
            allExtensions.forEach(ext => foundExtensions.add(ext.word));
            updateHookScore();
        }
        
        // Pre-load dictionary on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await loadDictionary();
        });
        
        // Start game with selected mode
        async function startGame(mode) {
            gameMode = mode;
            
            // Show loading message if dictionary not loaded
            if (!dictionaryLoaded) {
                const modeContainer = document.getElementById('modeContainer');
                modeContainer.innerHTML = `
                    <div class="loading-message">
                        <h2>Loading dictionary...</h2>
                        <div class="loading-spinner"></div>
                        <p>Please wait</p>
                    </div>
                `;
                
                await loadDictionary();
            }
            
            // For expert mode, show settings modal first
            if (mode === 'expert') {
                openComputerSettings();
                return;
            }
            
            launchGame(mode);
        }
        
        function openComputerSettings() {
            document.getElementById('computerSettingsModal').style.display = 'flex';
        }
        
        function closeComputerSettings() {
            document.getElementById('computerSettingsModal').style.display = 'none';
        }
        
        function selectSkillLevel(level) {
            computerSkillLevel = level;
            // Update UI
            document.querySelectorAll('.settings-option[data-skill]').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`.settings-option[data-skill="${level}"]`).classList.add('selected');
        }
        
        function selectDefensiveness(level) {
            computerDefensiveness = level;
            // Update UI
            document.querySelectorAll('.settings-option[data-defense]').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`.settings-option[data-defense="${level}"]`).classList.add('selected');
        }
        
        function selectTileVisibility(visibility) {
            hideComputerTiles = (visibility === 'hide');
            // Update UI
            document.querySelectorAll('.settings-option[data-visibility]').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`.settings-option[data-visibility="${visibility}"]`).classList.add('selected');
        }
        
        function startGameWithSettings() {
            closeComputerSettings();
            launchGame('expert');
        }
        
        function launchGame(mode) {
            document.getElementById('modeScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Update UI for expert mode
            if (mode === 'expert') {
                const skillLabels = {
                    'beginner': 'Beginner',
                    'intermediate': 'Intermediate', 
                    'expert': 'Expert'
                };
                const defenseLabels = {
                    'low': 'Aggressive',
                    'medium': 'Balanced',
                    'high': 'Defensive'
                };
                document.querySelector('.subtitle').textContent = `You vs ${skillLabels[computerSkillLevel]} Computer (${defenseLabels[computerDefensiveness]})`;
                document.getElementById('gameScreen').classList.add('expert-layout');
                updateStatsForExpertMode();
                setupExpertLayout();
            } else {
                document.getElementById('gameScreen').classList.remove('expert-layout');
            }
            
            initGame();
        }
        
        function setupExpertLayout() {
            // Create the expert mode layout: info left, board middle, controls right
            const gameArea = document.getElementById('gameArea');
            
            gameArea.innerHTML = `
                <div class="expert-game-area">
                    <div class="expert-side-panel expert-left-panel" id="expertSidePanel">
                        <div class="side-panel-section" id="computerTilesSection">
                            <h3>Computer's Tiles</h3>
                            <div class="side-computer-rack" id="sideComputerRack"></div>
                        </div>
                        <div class="side-panel-section">
                            <h3>Computer's Last Play</h3>
                            <div class="side-last-play" id="sideLastPlay">-</div>
                        </div>
                        <div class="side-panel-section side-feedback">
                            <h3>Your Play Analysis</h3>
                            <div class="feedback-content" id="sideFeedbackContent">
                                <p style="color: #7a4f2a; font-style: italic;">Play a word to see analysis here.</p>
                            </div>
                        </div>
                    </div>
                    <div class="expert-main-column">
                        <div class="board-container">
                            <div class="board" id="board"></div>
                        </div>
                    </div>
                    <div class="expert-right-panel">
                        <div class="side-panel-section side-controls">
                            <h3>Controls</h3>
                            <div class="side-buttons">
                                <button class="btn btn-clear" onclick="clearPlay()">Clear Play</button>
                                <button class="btn btn-clear" onclick="shuffleRack()">Shuffle</button>
                                <button class="btn btn-clear" onclick="openSwapModal()">Swap Tiles</button>
                                <button class="btn btn-skip" onclick="skipTurn()">Pass Turn</button>
                                <button class="btn btn-new" onclick="confirmNewGame()">New Game</button>
                                <button class="btn btn-new" onclick="confirmBackToMenu()">Menu</button>
                            </div>
                            <div class="side-pass-counter" id="sidePassCounter" style="display: none;">
                                Consecutive passes: <span id="sidePassCount">0</span>/6
                            </div>
                        </div>
                        <div class="side-panel-section side-submit-section">
                            <button class="btn btn-submit side-submit-btn" onclick="submitPlay()">Submit</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Hide the bottom controls in expert mode
            document.querySelectorAll('.controls').forEach(el => el.style.display = 'none');
        }
        
        function updateStatsForExpertMode() {
            const statsDiv = document.querySelector('.stats');
            statsDiv.innerHTML = `
                <div class="stat">
                    <div class="stat-value" id="totalScore">0</div>
                    <div class="stat-label">Your Score</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="computerScore">0</div>
                    <div class="stat-label">Computer</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="efficiency">-</div>
                    <div class="stat-label">Efficiency</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="tilesRemaining">93</div>
                    <div class="stat-label">Tiles in Bag</div>
                </div>
            `;
            // Computer rack and last play are now shown in side panel
        }
        
        // Initialize game
        function initGame() {
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            tileBag = [...FULL_BAG];
            shuffleArray(tileBag);
            isPlayerTurn = true;
            totalScore = 0;
            computerScore = 0;
            bestScore = 0;
            
            // 50/50 chance of starting with empty board or one word
            const startWithWord = Math.random() < 0.5;
            
            if (startWithWord) {
                const initialWordScore = generateInitialBoard();
                
                // In expert mode, the initial word counts as computer's first play
                if (gameMode === 'expert' && initialWordScore > 0) {
                    computerScore = initialWordScore;
                    updateComputerPlayDisplay(`Opening word for ${initialWordScore} points`);
                }
            }
            
            rack = drawTiles(7);
            if (gameMode === 'expert') {
                computerRack = drawTiles(7);
                renderComputerRack();
            }
            renderBoard();
            renderRack();
            updatePlayPreview();
            updateStats();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function drawTiles(count) {
            const drawn = [];
            for (let i = 0; i < count && tileBag.length > 0; i++) {
                drawn.push(tileBag.pop());
            }
            return drawn;
        }
        
        function generateInitialBoard() {
            // Place first word in center horizontally
            const words = Array.from(DICTIONARY).filter(w => w.length >= 3 && w.length <= 7);
            const firstWord = words[Math.floor(Math.random() * words.length)];
            const startCol = 7 - Math.floor(firstWord.length / 2);
            
            // Build play array for scoring
            const play = [];
            
            // Remove letters used for initial word from bag and place on board
            for (let i = 0; i < firstWord.length; i++) {
                board[7][startCol + i] = firstWord[i];
                play.push({row: 7, col: startCol + i, letter: firstWord[i], isBlank: false});
                const idx = tileBag.indexOf(firstWord[i]);
                if (idx !== -1) tileBag.splice(idx, 1);
            }
            
            // Calculate and return the score for this word
            const score = calculateScoreForInitialWord(play);
            return score;
        }
        
        // Special scoring function for initial word (first word is always double)
        function calculateScoreForInitialWord(play) {
            let wordScore = 0;
            
            for (const tile of play) {
                let letterScore = LETTER_POINTS[tile.letter] || 0;
                
                // Check for letter premium squares
                let premium = null;
                for (const [type, positions] of Object.entries(PREMIUM)) {
                    if (positions.some(([r, c]) => r === tile.row && c === tile.col)) {
                        premium = type;
                        break;
                    }
                }
                
                if (premium === 'DL') letterScore *= 2;
                if (premium === 'TL') letterScore *= 3;
                
                wordScore += letterScore;
            }
            
            // First word is ALWAYS doubled (center star)
            return wordScore * 2;
        }
        
        function canPlaceWord(word, row, col, dir, allowOverlap = false) {
            if (row < 0 || col < 0) return false;
            
            if (dir === 'across') {
                if (col + word.length > 15) return false;
                
                for (let i = 0; i < word.length; i++) {
                    const c = col + i;
                    if (board[row][c]) {
                        if (!allowOverlap || board[row][c] !== word[i]) return false;
                    }
                }
            } else {
                if (row + word.length > 15) return false;
                
                for (let i = 0; i < word.length; i++) {
                    const r = row + i;
                    if (board[r][col]) {
                        if (!allowOverlap || board[r][col] !== word[i]) return false;
                    }
                }
            }
            return true;
        }
        
        function placeWord(word, row, col, dir) {
            for (let i = 0; i < word.length; i++) {
                if (dir === 'across') {
                    if (!board[row][col + i]) {
                        board[row][col + i] = word[i];
                        const idx = tileBag.indexOf(word[i]);
                        if (idx !== -1) tileBag.splice(idx, 1);
                    }
                } else {
                    if (!board[row + i][col]) {
                        board[row + i][col] = word[i];
                        const idx = tileBag.indexOf(word[i]);
                        if (idx !== -1) tileBag.splice(idx, 1);
                    }
                }
            }
        }
        
        function renderBoard() {
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Premium squares
                    if (row === 7 && col === 7) {
                        cell.classList.add('center');
                        cell.innerHTML = '<span class="premium-label"></span>';
                    } else {
                        let premium = null;
                        for (const [type, positions] of Object.entries(PREMIUM)) {
                            if (positions.some(([r, c]) => r === row && c === col)) {
                                cell.classList.add(type.toLowerCase());
                                premium = type;
                                break;
                            }
                        }
                        if (premium && !board[row][col]) {
                            const labels = {TW: 'TW', DW: 'DW', TL: 'TL', DL: 'DL'};
                            cell.innerHTML = `<span class="premium-label">${labels[premium]}</span>`;
                        }
                    }
                    
                    // Letters
                    if (board[row][col]) {
                        cell.classList.add('occupied');
                        cell.innerHTML = `
                            <span class="letter">${board[row][col]}</span>
                            <span class="points">${LETTER_POINTS[board[row][col]] || 0}</span>
                        `;
                    }
                    
                    cell.addEventListener('click', () => selectCell(row, col));
                    
                    // Drag and drop for board cells
                    cell.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (!board[row][col] && !currentPlay.some(p => p.row === row && p.col === col)) {
                            cell.classList.add('drop-target');
                        }
                    });
                    
                    cell.addEventListener('dragleave', () => {
                        cell.classList.remove('drop-target');
                    });
                    
                    cell.addEventListener('drop', (e) => {
                        e.preventDefault();
                        cell.classList.remove('drop-target');
                        
                        const data = e.dataTransfer.getData('text/plain');
                        
                        // Check if tile is being moved from the board
                        if (data && data.startsWith('board:')) {
                            const playIndex = parseInt(data.split(':')[1]);
                            const movedTile = currentPlay[playIndex];
                            
                            // Don't drop on occupied cells or cells with other current play tiles
                            if (board[row][col] || currentPlay.some((p, i) => i !== playIndex && p.row === row && p.col === col)) {
                                return;
                            }
                            
                            // Update the tile's position
                            currentPlay[playIndex] = { ...movedTile, row, col };
                            
                            renderBoard();
                            renderRack();
                            updatePlayPreview();
                            return;
                        }
                        
                        if (draggedTileLetter && !board[row][col] && !currentPlay.some(p => p.row === row && p.col === col)) {
                            // Check if this is a blank tile
                            if (draggedTileLetter === '_') {
                                showBlankModal(row, col, draggedTileIndex);
                            } else {
                                // Add tile to current play
                                currentPlay.push({row, col, letter: draggedTileLetter, isBlank: false});
                                
                                // Auto-detect direction based on current play
                                if (currentPlay.length >= 2) {
                                    const isAcross = currentPlay.every(p => p.row === currentPlay[0].row);
                                    const isDown = currentPlay.every(p => p.col === currentPlay[0].col);
                                    if (isAcross) direction = 'across';
                                    else if (isDown) direction = 'down';
                                }
                                
                                renderBoard();
                                renderRack();
                                updatePlayPreview();
                            }
                        }
                    });
                    
                    boardDiv.appendChild(cell);
                }
            }
            
            // Show current play - make tiles draggable so they can be picked up and moved
            currentPlay.forEach(({row, col, letter, isBlank}, playIndex) => {
                const cell = boardDiv.children[row * 15 + col];
                cell.classList.add('preview');
                const blankClass = isBlank ? ' blank-letter' : '';
                cell.innerHTML = `
                    <span class="letter${blankClass}" draggable="true" data-play-index="${playIndex}">${letter}</span>
                    <span class="points">${isBlank ? 0 : (LETTER_POINTS[letter] || 0)}</span>
                `;
                
                // Make the placed tile draggable
                const letterSpan = cell.querySelector('.letter');
                letterSpan.style.cursor = 'grab';
                
                letterSpan.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(e.target.dataset.playIndex);
                    const playedTile = currentPlay[idx];
                    
                    // Store info about this tile being dragged from the board
                    draggedTileIndex = -1; // -1 indicates from board, not rack
                    draggedTileLetter = playedTile.isBlank ? '_' : playedTile.letter;
                    e.target.closest('.cell').classList.add('dragging-from');
                    
                    // Store the play index for removal
                    e.dataTransfer.setData('text/plain', `board:${idx}`);
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                letterSpan.addEventListener('dragend', (e) => {
                    e.target.closest('.cell').classList.remove('dragging-from');
                    
                    // Check if it was dropped on the rack or another cell
                    // The drop handler will take care of the rest
                });
            });
            
            // Highlight selected cell
            if (selectedCell) {
                const cell = boardDiv.children[selectedCell.row * 15 + selectedCell.col];
                cell.classList.add('selected');
            }
        }
        
        function renderRack() {
            const rackDiv = document.getElementById('rack');
            rackDiv.innerHTML = '';
            
            rack.forEach((letter, idx) => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                if (letter === '_') tile.classList.add('is-blank');
                tile.draggable = true;
                tile.dataset.index = idx;
                
                // Check if letter is used in current play
                // For blanks, we need to count how many blanks are used
                let isUsed = false;
                if (letter === '_') {
                    const blanksUsedCount = currentPlay.filter(p => p.isBlank).length;
                    const blanksInRackBeforeThis = rack.filter((l, i) => l === '_' && i < idx).length;
                    isUsed = blanksUsedCount > blanksInRackBeforeThis;
                } else {
                    const usedCount = currentPlay.filter(p => p.letter === letter && !p.isBlank).length;
                    const rackCount = rack.filter((l, i) => l === letter && i <= idx).length;
                    isUsed = usedCount >= rackCount;
                }
                
                if (isUsed) {
                    tile.classList.add('used');
                    tile.draggable = false;
                }
                
                tile.innerHTML = `
                    ${letter === '_' ? '' : letter}
                    <span class="points">${LETTER_POINTS[letter] || 0}</span>
                `;
                
                // Drag and drop events
                tile.addEventListener('dragstart', (e) => {
                    if (tile.classList.contains('used')) {
                        e.preventDefault();
                        return;
                    }
                    draggedTileIndex = idx;
                    draggedTileLetter = letter;
                    tile.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                tile.addEventListener('dragend', () => {
                    tile.classList.remove('dragging');
                    draggedTileIndex = null;
                    draggedTileLetter = null;
                    document.querySelectorAll('.tile').forEach(t => t.classList.remove('drag-over'));
                    document.querySelectorAll('.cell').forEach(c => c.classList.remove('drop-target'));
                });
                
                tile.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    tile.classList.add('drag-over');
                });
                
                tile.addEventListener('dragleave', () => {
                    tile.classList.remove('drag-over');
                });
                
                tile.addEventListener('drop', (e) => {
                    e.preventDefault();
                    tile.classList.remove('drag-over');
                    const targetIndex = parseInt(tile.dataset.index);
                    if (draggedTileIndex !== null && draggedTileIndex !== targetIndex && !draggedTileLetter) {
                        // This is a rack reorder (tile dropped on another tile in rack)
                    } else if (draggedTileIndex !== null && draggedTileIndex !== targetIndex) {
                        // Swap tiles in rack
                        const temp = rack[draggedTileIndex];
                        rack[draggedTileIndex] = rack[targetIndex];
                        rack[targetIndex] = temp;
                        renderRack();
                    }
                });
                
                rackDiv.appendChild(tile);
            });
            
            // Add drop handler to rack container for returning tiles from board
            rackDiv.ondragover = (e) => {
                e.preventDefault();
                rackDiv.classList.add('rack-drop-target');
            };
            
            rackDiv.ondragleave = (e) => {
                // Only remove if leaving the rack entirely
                if (!rackDiv.contains(e.relatedTarget)) {
                    rackDiv.classList.remove('rack-drop-target');
                }
            };
            
            rackDiv.ondrop = (e) => {
                e.preventDefault();
                rackDiv.classList.remove('rack-drop-target');
                
                const data = e.dataTransfer.getData('text/plain');
                
                // Check if tile is being returned from the board
                if (data && data.startsWith('board:')) {
                    const playIndex = parseInt(data.split(':')[1]);
                    
                    // Remove from current play (returns to rack automatically since rack tracks used tiles)
                    currentPlay.splice(playIndex, 1);
                    
                    renderBoard();
                    renderRack();
                    updatePlayPreview();
                }
            };
        }
        
        function renderComputerRack() {
            // Handle hiding the computer tiles section if setting enabled
            const tilesSection = document.getElementById('computerTilesSection');
            if (tilesSection) {
                tilesSection.style.display = hideComputerTiles ? 'none' : 'block';
            }
            
            // In expert mode, render to side panel
            const sideRack = document.getElementById('sideComputerRack');
            if (sideRack) {
                if (hideComputerTiles) {
                    sideRack.innerHTML = '<p style="color: #7a4f2a; font-style: italic;">Hidden</p>';
                    return;
                }
                sideRack.innerHTML = '';
                computerRack.forEach(letter => {
                    const tile = document.createElement('div');
                    tile.className = 'side-computer-tile';
                    tile.innerHTML = `
                        ${letter === '_' ? '' : letter}
                        <span class="points">${LETTER_POINTS[letter] || 0}</span>
                    `;
                    sideRack.appendChild(tile);
                });
                return;
            }
            
            // Fallback: Add computer rack container if it doesn't exist (non-expert mode shouldn't reach here)
            let container = document.querySelector('.computer-rack-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'computer-rack-container';
                container.innerHTML = `
                    <div class="computer-rack-label">Computer's Tiles:</div>
                    <div class="computer-rack" id="computerRack"></div>
                `;
                // Insert before the board
                const boardContainer = document.querySelector('.board-container');
                boardContainer.parentNode.insertBefore(container, boardContainer);
            }
            
            const rackDiv = document.getElementById('computerRack');
            rackDiv.innerHTML = '';
            
            computerRack.forEach(letter => {
                const tile = document.createElement('div');
                tile.className = 'computer-tile';
                tile.innerHTML = `
                    ${letter === '_' ? '' : letter}
                    <span class="points">${LETTER_POINTS[letter] || 0}</span>
                `;
                rackDiv.appendChild(tile);
            });
        }
        
        function selectCell(row, col) {
            // Don't allow selecting occupied cells
            if (board[row][col]) return;
            
            selectedCell = {row, col};
            renderBoard();
            
            // Focus on window to capture keyboard events
            window.focus();
        }
        
        function updatePlayPreview() {
            const previewDiv = document.getElementById('playPreview');
            const wordSpan = document.getElementById('previewWord');
            const scoreSpan = document.getElementById('previewScore');
            
            if (currentPlay.length === 0) {
                previewDiv.classList.add('empty');
                wordSpan.textContent = '-';
                scoreSpan.textContent = '0 pts';
                return;
            }
            
            previewDiv.classList.remove('empty');
            
            // Sort and determine direction
            const sortedPlay = [...currentPlay].sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            const isAcross = sortedPlay.every(p => p.row === sortedPlay[0].row);
            const playDir = isAcross ? 'across' : 'down';
            
            // Build the complete word including existing tiles
            const {row: startRow, col: startCol} = sortedPlay[0];
            let fullWord = '';
            
            if (playDir === 'across') {
                let start = startCol;
                while (start > 0 && (board[startRow][start - 1] || sortedPlay.some(p => p.row === startRow && p.col === start - 1))) {
                    start--;
                }
                let c = start;
                while (c < 15 && (board[startRow][c] || sortedPlay.some(p => p.row === startRow && p.col === c))) {
                    const playTile = sortedPlay.find(p => p.row === startRow && p.col === c);
                    fullWord += playTile ? playTile.letter : board[startRow][c];
                    c++;
                }
            } else {
                let start = startRow;
                while (start > 0 && (board[start - 1][startCol] || sortedPlay.some(p => p.row === start - 1 && p.col === startCol))) {
                    start--;
                }
                let r = start;
                while (r < 15 && (board[r][startCol] || sortedPlay.some(p => p.row === r && p.col === startCol))) {
                    const playTile = sortedPlay.find(p => p.row === r && p.col === startCol);
                    fullWord += playTile ? playTile.letter : board[r][startCol];
                    r++;
                }
            }
            
            // Calculate score for preview
            const score = calculateScore(sortedPlay, playDir);
            
            wordSpan.textContent = fullWord;
            scoreSpan.textContent = score + ' pts';
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            // Arrow keys to change direction
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
                direction = 'across';
                return;
            }
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                direction = 'down';
                return;
            }
            
            if (!selectedCell) return;
            
            const key = e.key.toUpperCase();
            
            if (e.key === 'Backspace') {
                if (currentPlay.length > 0) {
                    currentPlay.pop();
                    renderBoard();
                    renderRack();
                    updatePlayPreview();
                }
                return;
            }
            
            if (key.length === 1 && key >= 'A' && key <= 'Z') {
                // Check if we have this letter (or a blank)
                const usedLetters = currentPlay.filter(p => !p.isBlank).map(p => p.letter);
                const usedBlanks = currentPlay.filter(p => p.isBlank).length;
                const availableBlanks = rack.filter(l => l === '_').length - usedBlanks;
                
                const availableLetters = rack.filter(l => {
                    if (l === '_') return false; // Handle blanks separately
                    const used = usedLetters.filter(ul => ul === l).length;
                    const total = rack.filter(rl => rl === l).length;
                    return used < total;
                });
                
                const {row, col} = selectedCell;
                
                // Check if this position is already occupied
                if (board[row][col] || currentPlay.some(p => p.row === row && p.col === col)) {
                    return;
                }
                
                if (availableLetters.includes(key)) {
                    // Use the actual letter tile
                    currentPlay.push({row, col, letter: key, isBlank: false});
                } else if (availableBlanks > 0) {
                    // Use a blank tile for this letter
                    currentPlay.push({row, col, letter: key, isBlank: true});
                } else {
                    showFeedback(`You don't have the letter ${key}!`, 'error');
                    return;
                }
                
                // Move to next cell
                if (direction === 'across') {
                    selectedCell = {row, col: col + 1};
                } else {
                    selectedCell = {row: row + 1, col};
                }
                
                // Keep selection on board
                if (selectedCell.col >= 15) selectedCell.col = 14;
                if (selectedCell.row >= 15) selectedCell.row = 14;
                
                renderBoard();
                renderRack();
                updatePlayPreview();
            }
        });
        
        function clearPlay() {
            currentPlay = [];
            selectedCell = null;
            clearHighlights();
            renderBoard();
            renderRack();
            updatePlayPreview();
            hideFeedback();
        }
        
        function shuffleRack() {
            // Fisher-Yates shuffle
            for (let i = rack.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rack[i], rack[j]] = [rack[j], rack[i]];
            }
            renderRack();
        }
        
        // Get all words formed by a play (main word + cross words)
        function getAllFormedWords(play, playDir) {
            const words = [];
            
            // Helper to get letter at position (from board or current play)
            function getLetterAt(row, col) {
                const playTile = play.find(p => p.row === row && p.col === col);
                if (playTile) return playTile.letter;
                return board[row][col];
            }
            
            // Get the main word
            if (play.length > 0) {
                const {row: startRow, col: startCol} = play[0];
                let mainWord = '';
                
                if (playDir === 'across') {
                    let start = startCol;
                    while (start > 0 && getLetterAt(startRow, start - 1)) start--;
                    let c = start;
                    while (c < 15 && getLetterAt(startRow, c)) {
                        mainWord += getLetterAt(startRow, c);
                        c++;
                    }
                } else {
                    let start = startRow;
                    while (start > 0 && getLetterAt(start - 1, startCol)) start--;
                    let r = start;
                    while (r < 15 && getLetterAt(r, startCol)) {
                        mainWord += getLetterAt(r, startCol);
                        r++;
                    }
                }
                
                if (mainWord.length >= 2) {
                    words.push(mainWord);
                }
            }
            
            // Get cross words for each new tile
            const crossDir = playDir === 'across' ? 'down' : 'across';
            for (const tile of play) {
                let crossWord = '';
                
                if (crossDir === 'across') {
                    let start = tile.col;
                    while (start > 0 && getLetterAt(tile.row, start - 1)) start--;
                    let c = start;
                    while (c < 15 && getLetterAt(tile.row, c)) {
                        crossWord += getLetterAt(tile.row, c);
                        c++;
                    }
                } else {
                    let start = tile.row;
                    while (start > 0 && getLetterAt(start - 1, tile.col)) start--;
                    let r = start;
                    while (r < 15 && getLetterAt(r, tile.col)) {
                        crossWord += getLetterAt(r, tile.col);
                        r++;
                    }
                }
                
                if (crossWord.length >= 2) {
                    words.push(crossWord);
                }
            }
            
            return words;
        }
        
        // Validate all words formed by a play
        function validateAllWords(play, playDir) {
            const words = getAllFormedWords(play, playDir);
            const invalidWords = words.filter(w => !DICTIONARY.has(w));
            return {
                valid: invalidWords.length === 0,
                invalidWords: invalidWords,
                allWords: words
            };
        }
        
        function submitPlay() {
            if (currentPlay.length === 0) {
                showFeedback('Please place some tiles first!', 'error');
                return;
            }
            
            // Sort play positions
            currentPlay.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            // Determine direction
            const isAcross = currentPlay.every(p => p.row === currentPlay[0].row);
            const isDown = currentPlay.every(p => p.col === currentPlay[0].col);
            
            if (!isAcross && !isDown) {
                showFeedback('Letters must be in a straight line!', 'error');
                return;
            }
            
            const playDir = isAcross ? 'across' : 'down';
            
            // Check for gaps in the play
            if (currentPlay.length > 1) {
                if (playDir === 'across') {
                    const row = currentPlay[0].row;
                    const cols = currentPlay.map(p => p.col).sort((a, b) => a - b);
                    for (let c = cols[0]; c <= cols[cols.length - 1]; c++) {
                        if (!board[row][c] && !currentPlay.some(p => p.col === c)) {
                            showFeedback('There are gaps in your word!', 'error');
                            return;
                        }
                    }
                } else {
                    const col = currentPlay[0].col;
                    const rows = currentPlay.map(p => p.row).sort((a, b) => a - b);
                    for (let r = rows[0]; r <= rows[rows.length - 1]; r++) {
                        if (!board[r][col] && !currentPlay.some(p => p.row === r)) {
                            showFeedback('There are gaps in your word!', 'error');
                            return;
                        }
                    }
                }
            }
            
            // Validate ALL words formed (main word + cross words)
            const validation = validateAllWords(currentPlay, playDir);
            if (!validation.valid) {
                const invalidList = validation.invalidWords.map(w => `"${w}"`).join(', ');
                showFeedback(`Invalid word(s): ${invalidList}`, 'error');
                return;
            }
            
            // Check connection (must touch existing tile OR be first play covering center)
            const touchesExisting = currentPlay.some(({row, col}) => {
                return (row > 0 && board[row-1][col]) ||
                       (row < 14 && board[row+1][col]) ||
                       (col > 0 && board[row][col-1]) ||
                       (col < 14 && board[row][col+1]);
            });
            
            const coversCenter = currentPlay.some(p => p.row === 7 && p.col === 7);
            const hasExistingTiles = board.some(row => row.some(cell => cell !== null));
            
            // If board is empty, must cover center
            if (!hasExistingTiles && !coversCenter) {
                showFeedback('First word must cover the center star!', 'error');
                return;
            }
            
            // If board has tiles, must connect to them
            if (hasExistingTiles && !touchesExisting) {
                showFeedback('Word must connect to existing tiles!', 'error');
                return;
            }
            
            // Calculate score
            const score = calculateScore(currentPlay, playDir);
            totalScore += score;
            if (score > bestScore) bestScore = score;
            
            // Valid play made - reset consecutive passes
            consecutivePasses = 0;
            updatePassCounter();
            
            // Commit play to board
            currentPlay.forEach(({row, col, letter}) => {
                board[row][col] = letter;
            });
            
            // Build the main word for display
            const mainWord = validation.allWords[0] || '';
            
            // Save board state BEFORE finding better plays (for highlighting later)
            // In expert mode, we need to save this before computer plays
            const boardStateForBetterPlays = board.map(row => [...row]);
            
            // Find better plays using the board state BEFORE the play was committed
            // We need to temporarily restore the old board to find alternatives
            const boardAfterPlay = board.map(row => [...row]);
            currentPlay.forEach(({row, col}) => {
                board[row][col] = null; // Temporarily remove our play
            });
            const betterPlays = findBetterPlays(score, board);
            board = boardAfterPlay; // Restore board with our play
            
            // Store better plays for click highlighting
            lastBetterPlays = betterPlays;
            boardStateBeforeComputerPlay = boardStateForBetterPlays;
            selectedBetterPlayIndex = null;
            
            // Track efficiency
            turnsPlayed++;
            totalPointsScored += score;
            const optimalScore = betterPlays.length > 0 ? betterPlays[0].score : score;
            totalOptimalPoints += optimalScore;
            updateEfficiency();
            
            // Determine performance rating
            let performanceRating = '';
            if (betterPlays.length === 0) {
                performanceRating = 'Perfect';
            } else {
                const bestPossible = betterPlays[0].score;
                const percentage = (score / bestPossible) * 100;
                
                if (percentage >= 90) {
                    performanceRating = 'Excellent';
                } else if (percentage >= 80) {
                    performanceRating = 'Great';
                } else if (percentage >= 70) {
                    performanceRating = 'Good';
                } else if (percentage >= 50) {
                    performanceRating = 'Okay';
                } else {
                    performanceRating = 'Poor';
                }
            }
            
            // Show feedback
            let msg = `<h3>${performanceRating} Play!</h3>`;
            msg += `<div class="score-line">"${mainWord}" scores ${score} points!</div>`;
            
            if (validation.allWords.length > 1) {
                msg += `<p>Also formed: ${validation.allWords.slice(1).join(', ')}</p>`;
            }
            
            if (betterPlays.length > 0) {
                msg += `<div class="better-plays"><h4>Higher-scoring options (click to see on board):</h4>`;
                betterPlays.slice(0, 5).forEach((play, index) => {
                    msg += `<div class="play-option" onclick="highlightBetterPlay(${index})" data-index="${index}">${play.word} - ${play.score} pts (${play.location})</div>`;
                });
                msg += `</div>`;
            } else {
                msg += `<p><strong>This was the best available play!</strong></p>`;
            }
            
            showFeedback(msg, 'success');
            
            // Remove used tiles from rack
            currentPlay.forEach(({letter, isBlank}) => {
                if (isBlank) {
                    // Remove a blank tile from rack
                    const idx = rack.indexOf('_');
                    if (idx !== -1) rack.splice(idx, 1);
                } else {
                    // Remove the actual letter from rack
                    const idx = rack.indexOf(letter);
                    if (idx !== -1) rack.splice(idx, 1);
                }
            });
            
            // Draw new tiles to replace used ones
            const newTiles = drawTiles(7 - rack.length);
            rack = [...rack, ...newTiles];
            
            // Update game state
            currentPlay = [];
            selectedCell = null;
            
            renderBoard();
            renderRack();
            updateStats();
            
            // In expert mode, check for game end or trigger computer's turn
            if (gameMode === 'expert') {
                if (checkGameEnd()) return;
                setTimeout(() => computerTurn(), 1500);
            }
        }
        
        // Find all valid plays for a given rack, returns array sorted by score descending
        function findAllPlays(rackToUse) {
            const allPlays = [];
            
            // Count blanks in rack
            const blanksInRack = rackToUse.filter(t => t === '_').length;
            
            // Get all valid words we can make from the rack (including partial matches with board)
            const possibleWords = Array.from(DICTIONARY).filter(word => {
                if (word.length < 2 || word.length > 15) return false;
                return true;
            });
            
            // Try each word at each position
            for (const word of possibleWords) {
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        for (const dir of ['across', 'down']) {
                            // Check if word fits
                            if (dir === 'across' && col + word.length > 15) continue;
                            if (dir === 'down' && row + word.length > 15) continue;
                            
                            // Build the play - track blanks used
                            const play = [];
                            let valid = true;
                            let touchesExisting = false;
                            const rackCopy = [...rackToUse];
                            let blanksUsed = 0;
                            
                            for (let i = 0; i < word.length; i++) {
                                const r = dir === 'across' ? row : row + i;
                                const c = dir === 'across' ? col + i : col;
                                
                                if (board[r][c]) {
                                    if (board[r][c] !== word[i]) {
                                        valid = false;
                                        break;
                                    }
                                    touchesExisting = true;
                                } else {
                                    // Need this letter from rack - check for letter first, then blank
                                    const rackIdx = rackCopy.indexOf(word[i]);
                                    if (rackIdx !== -1) {
                                        rackCopy.splice(rackIdx, 1);
                                        play.push({row: r, col: c, letter: word[i], isBlank: false});
                                    } else {
                                        const blankIdx = rackCopy.indexOf('_');
                                        if (blankIdx !== -1) {
                                            rackCopy.splice(blankIdx, 1);
                                            play.push({row: r, col: c, letter: word[i], isBlank: true});
                                            blanksUsed++;
                                        } else {
                                            valid = false;
                                            break;
                                        }
                                    }
                                    
                                    if ((r > 0 && board[r-1][c]) || (r < 14 && board[r+1][c]) ||
                                        (c > 0 && board[r][c-1]) || (c < 14 && board[r][c+1])) {
                                        touchesExisting = true;
                                    }
                                }
                            }
                            
                            if (!valid || play.length === 0) continue;
                            
                            const hasExistingTiles = board.some(row => row.some(cell => cell !== null));
                            if (hasExistingTiles && !touchesExisting) continue;
                            
                            if (!hasExistingTiles) {
                                const coversCenter = play.some(p => p.row === 7 && p.col === 7);
                                if (!coversCenter) continue;
                            }
                            
                            const validation = validateAllWords(play, dir);
                            if (!validation.valid) continue;
                            
                            const score = calculateScore(play, dir);
                            allPlays.push({ word, row, col, dir, play, score });
                        }
                    }
                }
            }
            
            // Sort by score descending
            allPlays.sort((a, b) => b.score - a.score);
            return allPlays;
        }
        
        // Evaluate how "dangerous" a board position is after a play
        // Higher score = more dangerous (opens up premium squares for opponent)
        function evaluateBoardDanger(play) {
            let dangerScore = 0;
            
            // Simulate placing the tiles
            const tempBoard = board.map(row => [...row]);
            play.play.forEach(({row, col, letter}) => {
                tempBoard[row][col] = letter;
            });
            
            // Check each empty cell adjacent to any tile
            const checkedCells = new Set();
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (tempBoard[r][c]) continue; // Skip occupied cells
                    
                    // Check if this empty cell is adjacent to a tile
                    const hasAdjacentTile = 
                        (r > 0 && tempBoard[r-1][c]) ||
                        (r < 14 && tempBoard[r+1][c]) ||
                        (c > 0 && tempBoard[r][c-1]) ||
                        (c < 14 && tempBoard[r][c+1]);
                    
                    if (!hasAdjacentTile) continue;
                    
                    const cellKey = `${r},${c}`;
                    if (checkedCells.has(cellKey)) continue;
                    checkedCells.add(cellKey);
                    
                    // Check what premium square this is
                    const premium = getPremiumType(r, c);
                    
                    // Score based on premium type - these are dangerous openings
                    if (premium === 'TW') {
                        dangerScore += 25; // Triple word is very dangerous
                    } else if (premium === 'DW') {
                        dangerScore += 12; // Double word is moderately dangerous
                    } else if (premium === 'TL') {
                        dangerScore += 8; // Triple letter can enable big plays
                    } else if (premium === 'DL') {
                        dangerScore += 3; // Double letter is minor
                    }
                    
                    // Extra danger if opening a line to TW
                    if (premium !== 'TW') {
                        // Check if this cell opens a path to a TW
                        const twPositions = PREMIUM.TW;
                        for (const [twR, twC] of twPositions) {
                            // Same row, clear path
                            if (r === twR && !tempBoard[r][twC]) {
                                let clearPath = true;
                                const minC = Math.min(c, twC);
                                const maxC = Math.max(c, twC);
                                for (let checkC = minC + 1; checkC < maxC; checkC++) {
                                    if (tempBoard[r][checkC]) {
                                        clearPath = false;
                                        break;
                                    }
                                }
                                if (clearPath && maxC - minC <= 7) {
                                    dangerScore += 10;
                                }
                            }
                            // Same column, clear path
                            if (c === twC && !tempBoard[twR][c]) {
                                let clearPath = true;
                                const minR = Math.min(r, twR);
                                const maxR = Math.max(r, twR);
                                for (let checkR = minR + 1; checkR < maxR; checkR++) {
                                    if (tempBoard[checkR][c]) {
                                        clearPath = false;
                                        break;
                                    }
                                }
                                if (clearPath && maxR - minR <= 7) {
                                    dangerScore += 10;
                                }
                            }
                        }
                    }
                }
            }
            
            return dangerScore;
        }
        
        // Helper to get premium type for a cell
        function getPremiumType(row, col) {
            for (const [type, positions] of Object.entries(PREMIUM)) {
                if (positions.some(([r, c]) => r === row && c === col)) {
                    return type;
                }
            }
            return null;
        }
        
        // Calculate adjusted score factoring in defensiveness
        function getDefensiveAdjustedScore(play) {
            const dangerScore = evaluateBoardDanger(play);
            
            // Weight based on defensiveness setting
            let dangerWeight;
            if (computerDefensiveness === 'low') {
                dangerWeight = 0; // Ignore danger completely
            } else if (computerDefensiveness === 'medium') {
                dangerWeight = 0.5; // Moderate penalty
            } else { // high
                dangerWeight = 1.0; // Strong penalty
            }
            
            // Adjusted score = points - (danger * weight)
            return play.score - (dangerScore * dangerWeight);
        }
        
        // Select a play based on the computer's skill level and defensiveness
        function selectPlayBySkill(allPlays) {
            if (allPlays.length === 0) return null;
            
            // If defensiveness is not 'low', re-sort plays by defensive-adjusted score
            let playsToConsider = allPlays;
            if (computerDefensiveness !== 'low') {
                // Calculate adjusted scores and re-sort
                playsToConsider = allPlays.map(play => ({
                    ...play,
                    adjustedScore: getDefensiveAdjustedScore(play)
                }));
                playsToConsider.sort((a, b) => b.adjustedScore - a.adjustedScore);
            }
            
            if (computerSkillLevel === 'expert') {
                // Always pick the best play (by adjusted score if defensive)
                return playsToConsider[0];
            }
            
            if (computerSkillLevel === 'intermediate') {
                // Pick from the top 65% of plays, with some randomness
                const topCount = Math.max(1, Math.ceil(playsToConsider.length * 0.65));
                const topPlays = playsToConsider.slice(0, topCount);
                // Weight towards better plays but allow some variance
                const weights = topPlays.map((_, i) => topCount - i);
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                let random = Math.random() * totalWeight;
                for (let i = 0; i < topPlays.length; i++) {
                    random -= weights[i];
                    if (random <= 0) return topPlays[i];
                }
                return topPlays[0];
            }
            
            if (computerSkillLevel === 'beginner') {
                // Pick from the bottom 30% of plays (weaker moves)
                const startIdx = Math.floor(playsToConsider.length * 0.7);
                const weakerPlays = playsToConsider.slice(startIdx);
                
                if (weakerPlays.length === 0) {
                    // If not enough plays, just pick from bottom half
                    const bottomHalf = playsToConsider.slice(Math.floor(playsToConsider.length / 2));
                    if (bottomHalf.length === 0) return playsToConsider[playsToConsider.length - 1];
                    return bottomHalf[Math.floor(Math.random() * bottomHalf.length)];
                }
                
                // Pick randomly from weaker plays
                return weakerPlays[Math.floor(Math.random() * weakerPlays.length)];
            }
            
            // Default to best play
            return playsToConsider[0];
        }
        
        function computerTurn() {
            // Check if game should end
            if (tileBag.length === 0 && (computerRack.length === 0 || rack.length === 0)) {
                endGame();
                return;
            }
            
            if (computerRack.length === 0 && tileBag.length === 0) {
                endGame();
                return;
            }
            
            // Find all valid plays and select one based on skill level
            const allPlays = findAllPlays(computerRack);
            const selectedPlay = selectPlayBySkill(allPlays);
            
            if (!selectedPlay) {
                // No valid play, increment pass counter
                consecutivePasses++;
                updatePassCounter();
                updateComputerPlayDisplay('Passed (no valid plays)');
                
                if (checkGameEnd()) return;
                
                if (tileBag.length > 0) {
                    // Exchange tiles
                    const toExchange = Math.min(computerRack.length, tileBag.length, 3);
                    for (let i = 0; i < toExchange; i++) {
                        tileBag.push(computerRack.pop());
                    }
                    shuffleArray(tileBag);
                    const newTiles = drawTiles(7 - computerRack.length);
                    computerRack = [...computerRack, ...newTiles];
                    renderComputerRack();
                    updateStats();
                }
                return;
            }
            
            // Valid play found - reset consecutive passes
            consecutivePasses = 0;
            updatePassCounter();
            
            // Execute the play
            const { word, row, col, dir, play, score } = selectedPlay;
            
            // Place tiles on board
            play.forEach(({row, col, letter}) => {
                board[row][col] = letter;
            });
            
            // Remove used tiles from computer rack (handle blanks)
            play.forEach(({letter, isBlank}) => {
                if (isBlank) {
                    const idx = computerRack.indexOf('_');
                    if (idx !== -1) computerRack.splice(idx, 1);
                } else {
                    const idx = computerRack.indexOf(letter);
                    if (idx !== -1) computerRack.splice(idx, 1);
                }
            });
            
            // Draw new tiles
            const newTiles = drawTiles(7 - computerRack.length);
            computerRack = [...computerRack, ...newTiles];
            
            // Update score
            computerScore += score;
            
            // Update the persistent computer play display
            computerLastPlayText = `"${word}" for ${score} points`;
            updateComputerPlayDisplay(computerLastPlayText);
            
            renderBoard();
            renderComputerRack();
            updateStats();
            
            // Check if game has ended
            if (checkGameEnd()) return;
        }
        
        function updateComputerPlayDisplay(text) {
            // Update side panel in expert mode
            const sideLastPlay = document.getElementById('sideLastPlay');
            if (sideLastPlay) {
                sideLastPlay.textContent = text;
            }
            
            // Also update the old display if it exists
            const displayEl = document.getElementById('computerPlayText');
            if (displayEl) {
                displayEl.textContent = text;
            }
        }
        
        function findBestPlay(rackToUse) {
            let bestPlay = null;
            let bestScore = 0;
            
            // Count blanks in rack
            const blanksInRack = rackToUse.filter(t => t === '_').length;
            
            // Get all valid words we can make from the rack (including partial matches with board)
            const possibleWords = Array.from(DICTIONARY).filter(word => {
                if (word.length < 2 || word.length > 15) return false;
                return true;
            });
            
            // Try each word at each position
            for (const word of possibleWords) {
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        for (const dir of ['across', 'down']) {
                            // Check if word fits
                            if (dir === 'across' && col + word.length > 15) continue;
                            if (dir === 'down' && row + word.length > 15) continue;
                            
                            // Build the play - track blanks used
                            const play = [];
                            let valid = true;
                            let touchesExisting = false;
                            const rackCopy = [...rackToUse];
                            let blanksUsed = 0;
                            
                            for (let i = 0; i < word.length; i++) {
                                const r = dir === 'across' ? row : row + i;
                                const c = dir === 'across' ? col + i : col;
                                
                                if (board[r][c]) {
                                    if (board[r][c] !== word[i]) {
                                        valid = false;
                                        break;
                                    }
                                    touchesExisting = true;
                                } else {
                                    // Need this letter from rack - check for letter first, then blank
                                    const rackIdx = rackCopy.indexOf(word[i]);
                                    if (rackIdx !== -1) {
                                        // Have the actual letter
                                        rackCopy.splice(rackIdx, 1);
                                        play.push({row: r, col: c, letter: word[i], isBlank: false});
                                    } else {
                                        // Try to use a blank
                                        const blankIdx = rackCopy.indexOf('_');
                                        if (blankIdx !== -1) {
                                            rackCopy.splice(blankIdx, 1);
                                            play.push({row: r, col: c, letter: word[i], isBlank: true});
                                            blanksUsed++;
                                        } else {
                                            valid = false;
                                            break;
                                        }
                                    }
                                    
                                    // Check if adjacent to existing tile
                                    if ((r > 0 && board[r-1][c]) || (r < 14 && board[r+1][c]) ||
                                        (c > 0 && board[r][c-1]) || (c < 14 && board[r][c+1])) {
                                        touchesExisting = true;
                                    }
                                }
                            }
                            
                            if (!valid || play.length === 0) continue;
                            
                            // Must connect to existing tiles (unless board is empty)
                            const hasExistingTiles = board.some(row => row.some(cell => cell !== null));
                            if (hasExistingTiles && !touchesExisting) continue;
                            
                            // If board is empty, must cover center
                            if (!hasExistingTiles) {
                                const coversCenter = play.some(p => p.row === 7 && p.col === 7);
                                if (!coversCenter) continue;
                            }
                            
                            // Validate all formed words
                            const validation = validateAllWords(play, dir);
                            if (!validation.valid) continue;
                            
                            // Calculate score
                            const score = calculateScore(play, dir);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestPlay = { word, row, col, dir, play, score };
                            }
                        }
                    }
                }
            }
            
            return bestPlay;
        }
        
        function calculateScore(play, dir) {
            let totalScore = 0;
            
            // Check if this is the first play (board is empty)
            const isFirstPlay = !board.some(row => row.some(cell => cell !== null));
            
            // Helper to get premium type for a cell
            function getPremium(row, col) {
                for (const [type, positions] of Object.entries(PREMIUM)) {
                    if (positions.some(([r, c]) => r === row && c === col)) {
                        return type;
                    }
                }
                return null;
            }
            
            // Helper to check if a cell is part of the current play (new tile)
            function isNewTile(row, col) {
                return play.some(p => p.row === row && p.col === col);
            }
            
            // Helper to check if a tile is a blank
            function isBlankTile(row, col) {
                const playTile = play.find(p => p.row === row && p.col === col);
                return playTile && playTile.isBlank;
            }
            
            // Helper to get letter at position (from board or current play)
            function getLetterAt(row, col) {
                const playTile = play.find(p => p.row === row && p.col === col);
                if (playTile) return playTile.letter;
                return board[row][col];
            }
            
            // Score the main word
            function scoreWord(startRow, startCol, wordDir) {
                let wordScore = 0;
                let wordMultiplier = 1;
                let r = startRow;
                let c = startCol;
                
                // Find the start of the word
                if (wordDir === 'across') {
                    while (c > 0 && getLetterAt(r, c - 1)) c--;
                } else {
                    while (r > 0 && getLetterAt(r - 1, c)) r--;
                }
                
                // Score each letter in the word
                while (r < 15 && c < 15 && getLetterAt(r, c)) {
                    const letter = getLetterAt(r, c);
                    // Blank tiles are worth 0 points
                    let letterScore = isBlankTile(r, c) ? 0 : (LETTER_POINTS[letter] || 0);
                    
                    // Premium squares only apply if this is a NEW tile
                    if (isNewTile(r, c)) {
                        const premium = getPremium(r, c);
                        if (premium === 'DL') letterScore *= 2;
                        if (premium === 'TL') letterScore *= 3;
                        if (premium === 'DW') wordMultiplier *= 2;
                        if (premium === 'TW') wordMultiplier *= 3;
                        
                        // Center star doubles word on first play
                        if (isFirstPlay && r === 7 && c === 7) {
                            wordMultiplier *= 2;
                        }
                    }
                    
                    wordScore += letterScore;
                    
                    if (wordDir === 'across') c++;
                    else r++;
                }
                
                return wordScore * wordMultiplier;
            }
            
            // Get the length of a word at position
            function getWordLength(startRow, startCol, wordDir) {
                let r = startRow;
                let c = startCol;
                let length = 0;
                
                // Find the start
                if (wordDir === 'across') {
                    while (c > 0 && getLetterAt(r, c - 1)) c--;
                } else {
                    while (r > 0 && getLetterAt(r - 1, c)) r--;
                }
                
                // Count letters
                while (r < 15 && c < 15 && getLetterAt(r, c)) {
                    length++;
                    if (wordDir === 'across') c++;
                    else r++;
                }
                
                return length;
            }
            
            // Score the main word (in the direction of play)
            if (play.length > 0) {
                const mainWordLength = getWordLength(play[0].row, play[0].col, dir);
                if (mainWordLength >= 2) {
                    totalScore += scoreWord(play[0].row, play[0].col, dir);
                }
            }
            
            // Score any cross words formed by each new tile
            const crossDir = dir === 'across' ? 'down' : 'across';
            for (const tile of play) {
                const crossLength = getWordLength(tile.row, tile.col, crossDir);
                if (crossLength >= 2) {
                    totalScore += scoreWord(tile.row, tile.col, crossDir);
                }
            }
            
            // Bonus for using all 7 tiles
            if (play.length === 7) totalScore += 50;
            
            return totalScore;
        }
        
        function findBetterPlays(currentScore, boardState = null) {
            const better = [];
            const searchBoard = boardState || board;
            
            // Get all valid words we can make purely from rack
            const possibleWords = Array.from(DICTIONARY).filter(word => {
                if (word.length < 2 || word.length > 7) return false;
                
                // Check if we can make this word from our rack
                const rackCopy = [...rack];
                for (let letter of word) {
                    const idx = rackCopy.indexOf(letter);
                    if (idx === -1) return false;
                    rackCopy.splice(idx, 1);
                }
                return true;
            });
            
            // Check if board has existing tiles
            const hasExistingTiles = searchBoard.some(row => row.some(cell => cell !== null));
            
            // Temporarily use searchBoard for validation
            const originalBoard = board;
            board = searchBoard;
            
            // Try each word at positions that make sense
            for (let i = 0; i < Math.min(200, possibleWords.length); i++) {
                const word = possibleWords[i];
                
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        for (const dir of ['across', 'down']) {
                            // Check if word fits on board
                            if (dir === 'across' && col + word.length > 15) continue;
                            if (dir === 'down' && row + word.length > 15) continue;
                            
                            // Build the mock play - only for empty cells
                            const mockPlay = [];
                            let valid = true;
                            let touchesExisting = false;
                            let coversCenter = false;
                            
                            for (let j = 0; j < word.length; j++) {
                                const r = dir === 'across' ? row : row + j;
                                const c = dir === 'across' ? col + j : col;
                                
                                if (searchBoard[r][c]) {
                                    // Cell is occupied - word must match
                                    if (searchBoard[r][c] !== word[j]) {
                                        valid = false;
                                        break;
                                    }
                                    touchesExisting = true;
                                } else {
                                    // Empty cell - we place a tile here
                                    mockPlay.push({row: r, col: c, letter: word[j], isBlank: false});
                                    
                                    // Check if this cell is adjacent to existing tiles
                                    if ((r > 0 && searchBoard[r-1][c]) || 
                                        (r < 14 && searchBoard[r+1][c]) ||
                                        (c > 0 && searchBoard[r][c-1]) || 
                                        (c < 14 && searchBoard[r][c+1])) {
                                        touchesExisting = true;
                                    }
                                    
                                    // Check if covers center
                                    if (r === 7 && c === 7) {
                                        coversCenter = true;
                                    }
                                }
                            }
                            
                            if (!valid || mockPlay.length === 0) continue;
                            
                            // Validate connection rules
                            if (hasExistingTiles) {
                                // Must connect to existing tiles
                                if (!touchesExisting) continue;
                            } else {
                                // Empty board - must cover center
                                if (!coversCenter) continue;
                            }
                            
                            // Validate all formed words are in dictionary
                            const validation = validateAllWords(mockPlay, dir);
                            if (!validation.valid) continue;
                            
                            // Calculate score
                            const score = calculateScore(mockPlay, dir);
                            
                            if (score > currentScore) {
                                const location = `row ${row + 1}, col ${col + 1}, ${dir}`;
                                // Avoid duplicates
                                if (!better.some(b => b.word === word && b.score === score)) {
                                    better.push({
                                        word, 
                                        score, 
                                        location,
                                        positions: mockPlay.map(p => ({row: p.row, col: p.col, letter: p.letter})),
                                        dir
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Restore original board
            board = originalBoard;
            
            return better.sort((a, b) => b.score - a.score);
        }
        
        function updateStats() {
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('tilesRemaining').textContent = tileBag.length;
            
            if (gameMode === 'expert') {
                const compScoreEl = document.getElementById('computerScore');
                if (compScoreEl) compScoreEl.textContent = computerScore;
            } else {
                const bestScoreEl = document.getElementById('bestScore');
                if (bestScoreEl) bestScoreEl.textContent = bestScore;
            }
        }
        
        function updateEfficiency() {
            const efficiencyEl = document.getElementById('efficiency');
            if (!efficiencyEl) return;
            
            if (turnsPlayed === 0 || totalOptimalPoints === 0) {
                efficiencyEl.textContent = '-';
                efficiencyEl.style.color = '#f5e6d3';
            } else {
                const efficiency = Math.round((totalPointsScored / totalOptimalPoints) * 100);
                efficiencyEl.textContent = efficiency + '%';
                
                // Color code the efficiency
                if (efficiency >= 90) {
                    efficiencyEl.style.color = '#2ecc71'; // Green - excellent
                } else if (efficiency >= 75) {
                    efficiencyEl.style.color = '#f1c40f'; // Yellow - good
                } else if (efficiency >= 60) {
                    efficiencyEl.style.color = '#e67e22'; // Orange - okay
                } else {
                    efficiencyEl.style.color = '#e74c3c'; // Red - needs work
                }
            }
        }
        
        function showFeedback(message, type) {
            // In expert mode, show feedback in side panel
            const sideFeedback = document.getElementById('sideFeedbackContent');
            if (sideFeedback && gameMode === 'expert') {
                sideFeedback.innerHTML = `<div class="${type}">${message}</div>`;
            }
            
            // Also show in regular feedback area
            const feedback = document.getElementById('feedback');
            feedback.innerHTML = message;
            feedback.className = 'feedback visible ' + type;
        }
        
        function hideFeedback() {
            document.getElementById('feedback').className = 'feedback';
        }
        
        function backToMenu() {
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameScreen').classList.remove('expert-layout');
            
            // Reset the game area to default structure
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="board-container">
                    <div class="board" id="board"></div>
                </div>
            `;
            
            // Restore controls visibility (hidden in expert mode)
            document.querySelectorAll('.controls').forEach(el => el.style.display = 'flex');
            
            // Reset the mode screen content
            const modeScreen = document.getElementById('modeScreen');
            modeScreen.style.display = 'flex';
            
            const modeContainer = document.getElementById('modeContainer');
            modeContainer.innerHTML = `
                <h1>Letter Rip: Scrabble Practice</h1>
                <p class="mode-subtitle">Choose your game mode</p>
                
                <div class="mode-options">
                    <div class="mode-card" onclick="startGame('free')">
                        <h2>Free Play</h2>
                        <p>Practice at your own pace. Play words and see how you compare to the best possible plays.</p>
                    </div>
                    
                    <div class="mode-card" onclick="startGame('expert')">
                        <h2>Play Computer</h2>
                        <p>Play against a computer opponent. Choose from beginner, intermediate, or expert difficulty.</p>
                    </div>
                    
                    <div class="mode-card" onclick="openHookWords()">
                        <h2>Hook Words</h2>
                        <p>Practice hook words - letters that can be added to the front or back of existing words.</p>
                    </div>
                    
                    <div class="mode-card" onclick="openBingoPractice()">
                        <h2>Bingo Practice</h2>
                        <p>Practice finding 7 and 8-letter bingos! Use all your tiles for that 50-point bonus.</p>
                    </div>
                    
                    <div class="mode-card" onclick="openVocabulary()">
                        <h2>Vocabulary</h2>
                        <p>Learn new Scrabble words! See random words from the dictionary with their definitions.</p>
                    </div>
                </div>
                
                <button class="about-btn" onclick="openAbout()">About This App</button>
            `;
            
            totalScore = 0;
            computerScore = 0;
            bestScore = 0;
            consecutivePasses = 0;
            computerLastPlayText = '';
            totalPointsScored = 0;
            totalOptimalPoints = 0;
            turnsPlayed = 0;
            
            // Remove computer rack if exists
            const compRack = document.querySelector('.computer-rack-container');
            if (compRack) compRack.remove();
            
            // Remove computer last play display if exists
            const compLastPlay = document.getElementById('computerLastPlay');
            if (compLastPlay) compLastPlay.remove();
            
            // Reset stats display
            const statsDiv = document.querySelector('.stats');
            statsDiv.innerHTML = `
                <div class="stat">
                    <div class="stat-value" id="totalScore">0</div>
                    <div class="stat-label">Total Score</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="efficiency">-</div>
                    <div class="stat-label">Efficiency</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="tilesRemaining">93</div>
                    <div class="stat-label">Tiles in Bag</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="bestScore">0</div>
                    <div class="stat-label">Best Play</div>
                </div>
            `;
            
            // Reset pass counter
            updatePassCounter();
        }
        
        function confirmBackToMenu() {
            if (confirm('Are you sure you want to return to the menu? Your current game will be lost.')) {
                backToMenu();
            }
        }
        
        // Don't auto-start - wait for mode selection
    </script>
</body>
</html>
